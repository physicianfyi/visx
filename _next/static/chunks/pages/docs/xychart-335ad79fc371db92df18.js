(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6539],{48719:function(e,t,n){"use strict";n.r(t),n.d(t,{packageJson:function(){return l},default:function(){return c}});var r=n(77460),a=(n(2784),n(55984)),i=n(15755),o=n(52322),l=n(65542);function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function u(e){return(0,o.jsx)(a.Z,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){(0,r.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({},e))}var d={background:"#222"};function c(){return(0,o.jsx)(i.Z,{title:"XYChart",description:"<XYChart />",exampleRenderer:u,exampleUrl:"/xychart",tileStyles:d,detailsHeight:0})}},15707:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return ea}});var r={};n.r(r),n.d(r,{AnimatedAnnotation:function(){return w},AnimatedAreaSeries:function(){return fr},AnimatedAreaStack:function(){return vr},AnimatedAxis:function(){return H},AnimatedBarGroup:function(){return Rr},AnimatedBarSeries:function(){return Tr},AnimatedBarStack:function(){return Br},AnimatedGlyphSeries:function(){return Kr},AnimatedGrid:function(){return ae},AnimatedLineSeries:function(){return zr},Annotation:function(){return S},AnnotationCircleSubject:function(){return R},AnnotationConnector:function(){return B},AnnotationLabel:function(){return T},AnnotationLineSubject:function(){return F},AreaSeries:function(){return Ht},AreaStack:function(){return yn},Axis:function(){return le},BarGroup:function(){return jn},BarSeries:function(){return In},BarStack:function(){return Un},DataContext:function(){return d},DataProvider:function(){return ut},EventEmitterContext:function(){return we},EventEmitterProvider:function(){return Ve},GlyphSeries:function(){return er},Grid:function(){return ce},LineSeries:function(){return lr},ThemeContext:function(){return We},ThemeProvider:function(){return Hr},Tooltip:function(){return Ee},TooltipContext:function(){return fe},TooltipProvider:function(){return Ye},XYChart:function(){return At},allColors:function(){return Xe},buildChartTheme:function(){return ze},darkTheme:function(){return Wr},defaultColors:function(){return Ie},grayColors:function(){return Ne},lightTheme:function(){return He},useEventEmitter:function(){return Ae}});var a=n(2784),i=n(77460),o=n(23712),l=n(95822),s=n(45191),u=n(49663),d=a.createContext({});function c(e){var t;return e&&"bandwidth"in e&&null!==(t=null===e||void 0===e?void 0:e.bandwidth())&&void 0!==t?t:0}try{c.displayName="getScaleBandwidth",c.__docgenInfo={description:"",displayName:"getScaleBandwidth",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/getScaleBandwidth.ts#getScaleBandwidth"]={docgenInfo:c.__docgenInfo,name:"getScaleBandwidth",path:"../visx-xychart/src/utils/getScaleBandwidth.ts#getScaleBandwidth"})}catch(ta){}function p(e){return null!=e&&"number"===typeof e&&!Number.isNaN(e)&&Number.isFinite(e)}try{p.displayName="isValidNumber",p.__docgenInfo={description:"",displayName:"isValidNumber",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/typeguards/isValidNumber.ts#isValidNumber"]={docgenInfo:p.__docgenInfo,name:"isValidNumber",path:"../visx-xychart/src/typeguards/isValidNumber.ts#isValidNumber"})}catch(ta){}var m=n(52322),f=["AnnotationComponent","children","datum","dataKey","xAccessor","yAccessor","dx","dy"];function h(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function y(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?h(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):h(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function v(e){var t,n,r=e.AnnotationComponent,i=e.children,l=e.datum,s=e.dataKey,h=e.xAccessor,v=e.yAccessor,b=e.dx,g=void 0===b?0:b,S=e.dy,P=void 0===S?0:S,O=(0,o.Z)(e,f),x=(0,a.useContext)(d)||{},E=x.innerHeight,k=x.innerWidth,C=x.margin,w=x.xScale,A=x.yScale,D=x.dataRegistry,V=(0,a.useMemo)((function(){return w?c(w):0}),[w]),T=(0,a.useMemo)((function(){return A?c(A):0}),[A]);if((!h||!v)&&!s)return console.warn("[@visx/xychart/BaseAnnotation]: dataKey or x/yAccessors must be specified."),null;var j=h&&v||null==s?null:null===D||void 0===D?void 0:D.get(s),q=h||(null===j||void 0===j?void 0:j.xAccessor),B=v||(null===j||void 0===j?void 0:j.yAccessor);if(!w||!A||!k||!E||!q||!B||!C)return null;var _=(null!==(t=(0,u.Z)(w(q(l))))&&void 0!==t?t:NaN)+V/2,Y=(null!==(n=(0,u.Z)(A(B(l))))&&void 0!==n?n:NaN)+T/2,R=_+g+16>C.left+k?-g:g,L=Y+P+16>C.top+E?-P:P;return p(_)&&p(Y)?(0,m.jsx)(r,y(y({width:k,height:E},O),{},{x:_,y:Y,dx:R,dy:L,children:i})):null}try{v.displayName="BaseAnnotation",v.__docgenInfo={description:"",displayName:"BaseAnnotation",props:{children:{defaultValue:null,description:"Annotation children (Subject, Label, Connector)",name:"children",required:!0,type:{name:"ReactNode"}},dx:{defaultValue:null,description:"x delta of the Label from the Subject.",name:"dx",required:!1,type:{name:"number"}},dy:{defaultValue:null,description:"y delta of the Label from the Subject.",name:"dy",required:!1,type:{name:"number"}},onDragEnd:{defaultValue:null,description:"Callback invoked on drag end.",name:"onDragEnd",required:!1,type:{name:"({ x, y, dx, dy, event }: HandlerArgs) => void"}},onDragStart:{defaultValue:null,description:"Callback invoked on drag start.",name:"onDragStart",required:!1,type:{name:"({ x, y, dx, dy, event }: HandlerArgs) => void"}},canEditLabel:{defaultValue:null,description:"Whether the Label position (dx, dy) is editable.",name:"canEditLabel",required:!1,type:{name:"boolean"}},canEditSubject:{defaultValue:null,description:"Whether the Subject position (x, y) is editable.",name:"canEditSubject",required:!1,type:{name:"boolean"}},onDragMove:{defaultValue:null,description:"Callback invoked on drag move.",name:"onDragMove",required:!1,type:{name:"({ x, y, dx, dy, event }: HandlerArgs) => void"}},AnnotationComponent:{defaultValue:null,description:"Annotation component to render.",name:"AnnotationComponent",required:!0,type:{name:"FC<AnnotationProps> | FC<EditableAnnotationProps>"}},dataKey:{defaultValue:null,description:"Key for series to which datum belongs (used for x/yAccessors). Alternatively xAccessor + yAccessor may be specified.",name:"dataKey",required:!1,type:{name:"string"}},datum:{defaultValue:null,description:"Datum to annotate, used for Annotation positioning.",name:"datum",required:!0,type:{name:"Datum"}},xAccessor:{defaultValue:null,description:"If dataKey is not specified, you must specify an xAccessor for datum.",name:"xAccessor",required:!1,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"If dataKey is not specified, you must specify an yAccessor for datum.",name:"yAccessor",required:!1,type:{name:"(d: Datum) => ScaleInput<YScale>"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/annotation/private/BaseAnnotation.tsx#BaseAnnotation"]={docgenInfo:v.__docgenInfo,name:"BaseAnnotation",path:"../visx-xychart/src/components/annotation/private/BaseAnnotation.tsx#BaseAnnotation"})}catch(ta){}var b=["editable"];function g(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function S(e){var t=e.editable,n=(0,o.Z)(e,b);return(0,m.jsx)(v,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?g(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):g(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({AnnotationComponent:t?l.Z:s.Z},n))}try{S.displayName="Annotation",S.__docgenInfo={description:"",displayName:"Annotation",props:{editable:{defaultValue:null,description:"",name:"editable",required:!1,type:{name:"boolean"}},children:{defaultValue:null,description:"Annotation children (Subject, Label, Connector)",name:"children",required:!0,type:{name:"ReactNode"}},dx:{defaultValue:null,description:"x delta of the Label from the Subject.",name:"dx",required:!1,type:{name:"number"}},dy:{defaultValue:null,description:"y delta of the Label from the Subject.",name:"dy",required:!1,type:{name:"number"}},onDragEnd:{defaultValue:null,description:"Callback invoked on drag end.",name:"onDragEnd",required:!1,type:{name:"({ x, y, dx, dy, event }: HandlerArgs) => void"}},onDragStart:{defaultValue:null,description:"Callback invoked on drag start.",name:"onDragStart",required:!1,type:{name:"({ x, y, dx, dy, event }: HandlerArgs) => void"}},canEditLabel:{defaultValue:null,description:"Whether the Label position (dx, dy) is editable.",name:"canEditLabel",required:!1,type:{name:"boolean"}},canEditSubject:{defaultValue:null,description:"Whether the Subject position (x, y) is editable.",name:"canEditSubject",required:!1,type:{name:"boolean"}},onDragMove:{defaultValue:null,description:"Callback invoked on drag move.",name:"onDragMove",required:!1,type:{name:"({ x, y, dx, dy, event }: HandlerArgs) => void"}},dataKey:{defaultValue:null,description:"Key for series to which datum belongs (used for x/yAccessors). Alternatively xAccessor + yAccessor may be specified.",name:"dataKey",required:!1,type:{name:"string"}},datum:{defaultValue:null,description:"Datum to annotate, used for Annotation positioning.",name:"datum",required:!0,type:{name:"Datum"}},xAccessor:{defaultValue:null,description:"If dataKey is not specified, you must specify an xAccessor for datum.",name:"xAccessor",required:!1,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"If dataKey is not specified, you must specify an yAccessor for datum.",name:"yAccessor",required:!1,type:{name:"(d: Datum) => ScaleInput<YScale>"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/annotation/Annotation.tsx#Annotation"]={docgenInfo:S.__docgenInfo,name:"Annotation",path:"../visx-xychart/src/components/annotation/Annotation.tsx#Annotation"})}catch(ta){}var P=n(75868),O=["x","y","AnnotationComponent"],x=["editable"];function E(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function k(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?E(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):E(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function C(e){var t=e.x,n=void 0===t?0:t,r=e.y,i=void 0===r?0:r,l=e.AnnotationComponent,s=(0,o.Z)(e,O),u=(0,a.useRef)({x:n,y:i}),d=(0,P.useSpring)({from:{x:u.current.x-n,y:u.current.y-i},to:{x:0,y:0},reset:!0});return(0,a.useEffect)((function(){u.current={x:n,y:i}}),[n,i]),(0,m.jsx)(P.animated.g,{transform:(0,P.to)([d.x,d.y],(function(e,t){return"translate(".concat(e,", ").concat(t,")")})),children:(0,m.jsx)(l,k({x:n,y:i},s))})}function w(e){var t=e.editable,n=(0,o.Z)(e,x),r=(0,a.useCallback)((function(e){return(0,m.jsx)(C,k({AnnotationComponent:t?l.Z:s.Z},e))}),[t]);return(0,m.jsx)(v,k({AnnotationComponent:r},n))}try{w.displayName="AnimatedAnnotation",w.__docgenInfo={description:"",displayName:"AnimatedAnnotation",props:{editable:{defaultValue:null,description:"",name:"editable",required:!1,type:{name:"boolean"}},children:{defaultValue:null,description:"Annotation children (Subject, Label, Connector)",name:"children",required:!0,type:{name:"ReactNode"}},dx:{defaultValue:null,description:"x delta of the Label from the Subject.",name:"dx",required:!1,type:{name:"number"}},dy:{defaultValue:null,description:"y delta of the Label from the Subject.",name:"dy",required:!1,type:{name:"number"}},onDragEnd:{defaultValue:null,description:"Callback invoked on drag end.",name:"onDragEnd",required:!1,type:{name:"({ x, y, dx, dy, event }: HandlerArgs) => void"}},onDragStart:{defaultValue:null,description:"Callback invoked on drag start.",name:"onDragStart",required:!1,type:{name:"({ x, y, dx, dy, event }: HandlerArgs) => void"}},canEditLabel:{defaultValue:null,description:"Whether the Label position (dx, dy) is editable.",name:"canEditLabel",required:!1,type:{name:"boolean"}},canEditSubject:{defaultValue:null,description:"Whether the Subject position (x, y) is editable.",name:"canEditSubject",required:!1,type:{name:"boolean"}},onDragMove:{defaultValue:null,description:"Callback invoked on drag move.",name:"onDragMove",required:!1,type:{name:"({ x, y, dx, dy, event }: HandlerArgs) => void"}},dataKey:{defaultValue:null,description:"Key for series to which datum belongs (used for x/yAccessors). Alternatively xAccessor + yAccessor may be specified.",name:"dataKey",required:!1,type:{name:"string"}},datum:{defaultValue:null,description:"Datum to annotate, used for Annotation positioning.",name:"datum",required:!0,type:{name:"Datum"}},xAccessor:{defaultValue:null,description:"If dataKey is not specified, you must specify an xAccessor for datum.",name:"xAccessor",required:!1,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"If dataKey is not specified, you must specify an yAccessor for datum.",name:"yAccessor",required:!1,type:{name:"(d: Datum) => ScaleInput<YScale>"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/annotation/AnimatedAnnotation.tsx#AnimatedAnnotation"]={docgenInfo:w.__docgenInfo,name:"AnimatedAnnotation",path:"../visx-xychart/src/components/annotation/AnimatedAnnotation.tsx#AnimatedAnnotation"})}catch(ta){}var A=n(57007);function D(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}var V={fillOpacity:.7};function T(e){var t=(0,a.useContext)(d),n=t.theme,r=t.resizeObserverPolyfill,o=null===n||void 0===n?void 0:n.svgLabelBig,l=null===n||void 0===n?void 0:n.svgLabelSmall;return(0,m.jsx)(A.Z,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?D(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):D(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({anchorLineStroke:null===n||void 0===n?void 0:n.axisStyles.x.bottom.axisLine.stroke,backgroundFill:null===n||void 0===n?void 0:n.backgroundColor,backgroundProps:V,showAnchorLine:!0,subtitleFontSize:null===l||void 0===l?void 0:l.fontSize,subtitleFontWeight:null===l||void 0===l?void 0:l.fontWeight,subtitleProps:l,titleFontSize:null===o||void 0===o?void 0:o.fontSize,titleFontWeight:null===o||void 0===o?void 0:o.fontWeight,titleProps:o,resizeObserverPolyfill:r},e))}try{T.displayName="AnnotationLabel",T.__docgenInfo={description:"AnnotationLabel which provides text styles from theme.",displayName:"AnnotationLabel",props:{anchorLineStroke:{defaultValue:null,description:"Stroke color of anchor line.",name:"anchorLineStroke",required:!1,type:{name:"string"}},backgroundFill:{defaultValue:null,description:"Background color of label.",name:"backgroundFill",required:!1,type:{name:"string"}},backgroundPadding:{defaultValue:null,description:"Padding of text from background.",name:"backgroundPadding",required:!1,type:{name:"number | { top?: number; right?: number; bottom?: number; left?: number; }"}},backgroundProps:{defaultValue:null,description:"Additional props to be passed to background SVGRectElement.",name:"backgroundProps",required:!1,type:{name:"SVGProps<SVGRectElement>"}},className:{defaultValue:null,description:"Optional className to apply to container in addition to 'visx-annotation-label'.",name:"className",required:!1,type:{name:"string"}},fontColor:{defaultValue:null,description:"Color of title and subtitle text.",name:"fontColor",required:!1,type:{name:"string"}},horizontalAnchor:{defaultValue:null,description:"Whether the label is horizontally anchored to the start, middle, or end of its x position.",name:"horizontalAnchor",required:!1,type:{name:'"end" | "middle" | "inherit" | "start"'}},resizeObserverPolyfill:{defaultValue:null,description:"Optionally inject a ResizeObserver polyfill, else this *must* be globally available.",name:"resizeObserverPolyfill",required:!1,type:{name:"new (cb: ResizeObserverCallback) => ResizeObserver"}},showAnchorLine:{defaultValue:null,description:"Whether to render a line indicating label text anchor.",name:"showAnchorLine",required:!1,type:{name:"boolean"}},showBackground:{defaultValue:null,description:"Whether to render a label background.",name:"showBackground",required:!1,type:{name:"boolean"}},subtitle:{defaultValue:null,description:"Optional subtitle.",name:"subtitle",required:!1,type:{name:"string"}},subtitleFontSize:{defaultValue:null,description:"Optional title font size.",name:"subtitleFontSize",required:!1,type:{name:"ReactText"}},subtitleFontWeight:{defaultValue:null,description:"Optional title font weight.",name:"subtitleFontWeight",required:!1,type:{name:"ReactText"}},subtitleDy:{defaultValue:null,description:"The vertical offset of the subtitle from the title.",name:"subtitleDy",required:!1,type:{name:"number"}},subtitleProps:{defaultValue:null,description:"Optional subtitle Text props (to override color, etc.).",name:"subtitleProps",required:!1,type:{name:"Partial<TextProps>"}},title:{defaultValue:null,description:"Optional title.",name:"title",required:!1,type:{name:"string"}},titleFontSize:{defaultValue:null,description:"Optional title font size.",name:"titleFontSize",required:!1,type:{name:"ReactText"}},titleFontWeight:{defaultValue:null,description:"Optional title font weight.",name:"titleFontWeight",required:!1,type:{name:"ReactText"}},titleProps:{defaultValue:null,description:"Optional title Text props (to override color, etc.).",name:"titleProps",required:!1,type:{name:"Partial<TextProps>"}},verticalAnchor:{defaultValue:null,description:"Whether the label is vertically anchored to the start, middle, or end of its y position.",name:"verticalAnchor",required:!1,type:{name:'"end" | "middle" | "start"'}},width:{defaultValue:null,description:"Width of annotation, including background, for text wrapping.",name:"width",required:!1,type:{name:"number"}},maxWidth:{defaultValue:null,description:"Max width of annotation, including background, for text wrapping.",name:"maxWidth",required:!1,type:{name:"number"}},x:{defaultValue:null,description:"Left offset of entire AnnotationLabel, if not specified uses x + dx from Annotation.",name:"x",required:!1,type:{name:"number"}},y:{defaultValue:null,description:"Top offset of entire AnnotationLabel, if not specified uses y + dy from Annotation.",name:"y",required:!1,type:{name:"number"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/annotation/AnnotationLabel.tsx#AnnotationLabel"]={docgenInfo:T.__docgenInfo,name:"AnnotationLabel",path:"../visx-xychart/src/components/annotation/AnnotationLabel.tsx#AnnotationLabel"})}catch(ta){}var j=n(27282);function q(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function B(e){var t=(0,a.useContext)(d).theme;return(0,m.jsx)(j.Z,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?q(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):q(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({stroke:null===t||void 0===t?void 0:t.axisStyles.x.bottom.axisLine.stroke},e))}try{B.displayName="AnnotationConnector",B.__docgenInfo={description:"AnnotationConnector which provides color from theme.",displayName:"AnnotationConnector",props:{x:{defaultValue:null,description:"x position of the Subject.",name:"x",required:!1,type:{name:"number"}},y:{defaultValue:null,description:"y position of the Subject.",name:"y",required:!1,type:{name:"number"}},dx:{defaultValue:null,description:"x delta of the Label from the Subject.",name:"dx",required:!1,type:{name:"number"}},dy:{defaultValue:null,description:"y delta of the Label from the Subject.",name:"dy",required:!1,type:{name:"number"}},className:{defaultValue:null,description:"Optional className to apply to container in addition to 'visx-annotation-connector'.",name:"className",required:!1,type:{name:"string"}},type:{defaultValue:null,description:"Connector type.",name:"type",required:!1,type:{name:'"line" | "elbow"'}},stroke:{defaultValue:null,description:"Color of the connector line.",name:"stroke",required:!1,type:{name:"string"}},pathProps:{defaultValue:null,description:"Optional additional props.",name:"pathProps",required:!1,type:{name:"SVGProps<SVGPathElement>"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/annotation/AnnotationConnector.tsx#AnnotationConnector"]={docgenInfo:B.__docgenInfo,name:"AnnotationConnector",path:"../visx-xychart/src/components/annotation/AnnotationConnector.tsx#AnnotationConnector"})}catch(ta){}var _=n(7424);function Y(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function R(e){var t=(0,a.useContext)(d).theme;return(0,m.jsx)(_.Z,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Y(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Y(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({stroke:null===t||void 0===t?void 0:t.axisStyles.x.bottom.axisLine.stroke},e))}try{R.displayName="AnnotationCircleSubject",R.__docgenInfo={description:"AnnotationSubjectCircle which provides color from theme.",displayName:"AnnotationCircleSubject",props:{x:{defaultValue:null,description:"x position of the Subject.",name:"x",required:!1,type:{name:"number"}},y:{defaultValue:null,description:"y position of the Subject.",name:"y",required:!1,type:{name:"number"}},className:{defaultValue:null,description:"Optional className to apply to CircleSubject in addition to 'visx-annotation-subject'.",name:"className",required:!1,type:{name:"string"}},stroke:{defaultValue:null,description:"Color of CircleSubject.",name:"stroke",required:!1,type:{name:"string"}},radius:{defaultValue:null,description:"Radius of CircleSubject.",name:"radius",required:!1,type:{name:"number"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/annotation/AnnotationCircleSubject.tsx#AnnotationCircleSubject"]={docgenInfo:R.__docgenInfo,name:"AnnotationCircleSubject",path:"../visx-xychart/src/components/annotation/AnnotationCircleSubject.tsx#AnnotationCircleSubject"})}catch(ta){}var L=n(63358),X=["min","max"];function N(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function F(e){var t,n,r,l=e.min,s=e.max,u=(0,o.Z)(e,X),c=(0,a.useContext)(d),p=c.theme,f=c.margin,h=c.innerHeight,y=void 0===h?0:h,v=c.innerWidth,b=void 0===v?0:v;return(0,m.jsx)(L.Z,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?N(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):N(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({stroke:null===p||void 0===p?void 0:p.axisStyles.x.bottom.axisLine.stroke,min:null!==(t=null!==l&&void 0!==l?l:"horizontal"===u.orientation?null===f||void 0===f?void 0:f.left:null===f||void 0===f?void 0:f.top)&&void 0!==t?t:0,max:null!==s&&void 0!==s?s:"horizontal"===u.orientation?(null!==(n=null===f||void 0===f?void 0:f.left)&&void 0!==n?n:0)+b:(null!==(r=null===f||void 0===f?void 0:f.top)&&void 0!==r?r:0)+y},u))}try{F.displayName="AnnotationLineSubject",F.__docgenInfo={description:"AnnotationLineSubject which provides color and dimensions from context.",displayName:"AnnotationLineSubject",props:{x:{defaultValue:null,description:"x position of LineSubject (for vertical LineSubjects).",name:"x",required:!1,type:{name:"number"}},y:{defaultValue:null,description:"y position of LineSubject (for horizontal LineSubjects).",name:"y",required:!1,type:{name:"number"}},className:{defaultValue:null,description:"Optional className to apply to LineSubject in addition to 'visx-annotation-subject'.",name:"className",required:!1,type:{name:"string"}},stroke:{defaultValue:null,description:"Color of LineSubject.",name:"stroke",required:!1,type:{name:"string"}},orientation:{defaultValue:null,description:"Orientation of line.",name:"orientation",required:!1,type:{name:'"horizontal" | "vertical"'}},strokeWidth:{defaultValue:null,description:"strokeWidth of LineSubject.",name:"strokeWidth",required:!1,type:{name:"number"}},min:{defaultValue:null,description:"",name:"min",required:!1,type:{name:"number"}},max:{defaultValue:null,description:"",name:"max",required:!1,type:{name:"number"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/annotation/AnnotationLineSubject.tsx#AnnotationLineSubject"]={docgenInfo:F.__docgenInfo,name:"AnnotationLineSubject",path:"../visx-xychart/src/components/annotation/AnnotationLineSubject.tsx#AnnotationLineSubject"})}catch(ta){}var I=n(89193),G=["AxisComponent"];function K(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function M(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?K(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):K(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Z(e){var t,n,r,i,l,s,u,c=e.AxisComponent,p=(0,o.Z)(e,G),f=(0,a.useContext)(d),h=f.theme,y=f.xScale,v=f.yScale,b=f.margin,g=f.width,S=f.height,P=p.orientation,O=(0,a.useMemo)((function(){var e,t,n,r;return"left"===P||"right"===P?null===h||void 0===h||null===(e=h.axisStyles)||void 0===e||null===(t=e.y)||void 0===t?void 0:t[P]:null===h||void 0===h||null===(n=h.axisStyles)||void 0===n||null===(r=n.x)||void 0===r?void 0:r[P]}),[h,P]),x=p.tickLabelProps,E=(0,a.useMemo)((function(){return x||O?function(e,t,n){return M(M({},null===O||void 0===O?void 0:O.tickLabel),{},{width:"left"===P||"right"===P?null===b||void 0===b?void 0:b[P]:void 0},"function"===typeof x?x(e,t,n):x)}:void 0}),[x,O,P,b]),k="bottom"===P?(null!==S&&void 0!==S?S:0)-(null!==(t=null===b||void 0===b?void 0:b.bottom)&&void 0!==t?t:0):"top"===P&&null!==(n=null===b||void 0===b?void 0:b.top)&&void 0!==n?n:0,C="left"===P?null!==(r=null===b||void 0===b?void 0:b.left)&&void 0!==r?r:0:"right"===P?(null!==g&&void 0!==g?g:0)-(null!==(i=null===b||void 0===b?void 0:b.right)&&void 0!==i?i:0):0,w="left"===P||"right"===P?v:y;return w?(0,m.jsx)(c,M(M({top:k,left:C,labelProps:null===O||void 0===O?void 0:O.axisLabel,stroke:null===O||void 0===O||null===(l=O.axisLine)||void 0===l?void 0:l.stroke,strokeWidth:null===O||void 0===O||null===(s=O.axisLine)||void 0===s?void 0:s.strokeWidth,tickLength:null===O||void 0===O?void 0:O.tickLength,tickStroke:null===O||void 0===O||null===(u=O.tickLine)||void 0===u?void 0:u.stroke},p),{},{tickLabelProps:E,scale:w})):null}try{Z.displayName="BaseAxis",Z.__docgenInfo={description:"Component which handles all xychart-specific logic for axes,\nand passes processed props to a specified Axis / AnimatedAxis component.",displayName:"BaseAxis",props:{children:{defaultValue:null,description:"For more control over rendering or to add event handlers to datum, pass a function as children.",name:"children",required:!1,type:{name:"(renderProps: AxisRendererProps<Scale>) => ReactNode"}},stroke:{defaultValue:null,description:"The color for the stroke of the lines.",name:"stroke",required:!1,type:{name:"string"}},strokeDasharray:{defaultValue:null,description:"The pattern of dashes in the stroke.",name:"strokeDasharray",required:!1,type:{name:"string"}},strokeWidth:{defaultValue:null,description:"The pixel value for the width of the lines.",name:"strokeWidth",required:!1,type:{name:"ReactText"}},innerRef:{defaultValue:null,description:"The ref to the outermost axis group element.",name:"innerRef",required:!1,type:{name:"Ref<SVGGElement>"}},top:{defaultValue:null,description:"A top pixel offset applied to the entire axis.",name:"top",required:!1,type:{name:"number"}},left:{defaultValue:null,description:"A left pixel offset applied to the entire axis.",name:"left",required:!1,type:{name:"number"}},hideTicks:{defaultValue:null,description:"If true, will hide the ticks (but not the tick labels).",name:"hideTicks",required:!1,type:{name:"boolean"}},tickClassName:{defaultValue:null,description:"The class name applied to each tick group.",name:"tickClassName",required:!1,type:{name:"string"}},tickComponent:{defaultValue:null,description:"Override the component used to render tick labels (instead of <Text /> from @visx/text).",name:"tickComponent",required:!1,type:{name:"(tickRendererProps: TickRendererProps) => ReactNode"}},tickStroke:{defaultValue:null,description:"The color for the tick's stroke value.",name:"tickStroke",required:!1,type:{name:"string"}},tickTransform:{defaultValue:null,description:"A custom SVG transform value to be applied to each tick group.",name:"tickTransform",required:!1,type:{name:"string"}},tickLineProps:{defaultValue:null,description:"Props to be applied to individual tick lines.",name:"tickLineProps",required:!1,type:{name:'Pick<SVGProps<SVGLineElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | "radius" | "color" | ... 453 more ... | "key">'}},numTicks:{defaultValue:null,description:"The number of ticks wanted for the axis (note this is approximate)",name:"numTicks",required:!1,type:{name:"number"}},tickValues:{defaultValue:null,description:"An array of values that determine the number and values of the ticks. Falls back to `scale.ticks()` or `.domain()`.",name:"tickValues",required:!1,type:{name:"ScaleInput<Scale>[]"}},label:{defaultValue:null,description:"The text for the axis label.",name:"label",required:!1,type:{name:"string"}},ticksComponent:{defaultValue:null,description:"Override the component used to render all tick lines and labels.",name:"ticksComponent",required:!1,type:{name:"(tickRendererProps: TicksRendererProps<Scale>) => ReactNode"}},axisLineClassName:{defaultValue:null,description:"The class name applied to the axis line element.",name:"axisLineClassName",required:!1,type:{name:"string"}},hideAxisLine:{defaultValue:null,description:"If true, will hide the axis line.",name:"hideAxisLine",required:!1,type:{name:"boolean"}},hideZero:{defaultValue:null,description:"If true, will hide the '0' value tick and tick label.",name:"hideZero",required:!1,type:{name:"boolean"}},labelClassName:{defaultValue:null,description:"The class name applied to the axis label text element.",name:"labelClassName",required:!1,type:{name:"string"}},labelOffset:{defaultValue:null,description:"Pixel offset of the axis label (does not include tick label font size, which is accounted for automatically)",name:"labelOffset",required:!1,type:{name:"number"}},labelProps:{defaultValue:null,description:"Props applied to the axis label component.",name:"labelProps",required:!1,type:{name:"Partial<TextProps>"}},rangePadding:{defaultValue:null,description:"Pixel padding to apply to axis sides.",name:"rangePadding",required:!1,type:{name:"number | { start?: number; end?: number; }"}},tickFormat:{defaultValue:null,description:"A [d3 formatter](https://github.com/d3/d3-scale/blob/master/README.md#continuous_tickFormat) for the tick text.",name:"tickFormat",required:!1,type:{name:"TickFormatter<ScaleInput<Scale>>"}},tickLabelProps:{defaultValue:null,description:"Either an object with the props for all tick labels or a function that returns props for a given tick label.",name:"tickLabelProps",required:!1,type:{name:"TickLabelProps<ScaleInput<Scale>>"}},tickLength:{defaultValue:null,description:"The length of the tick lines.",name:"tickLength",required:!1,type:{name:"number"}},axisClassName:{defaultValue:null,description:"The class name applied to the outermost axis group element.",name:"axisClassName",required:!1,type:{name:"string"}},orientation:{defaultValue:null,description:"Required axis orientation.",name:"orientation",required:!0,type:{name:'"top" | "left" | "right" | "bottom"'}},AxisComponent:{defaultValue:null,description:"Rendered component which is passed VxAxisProps by BaseAxis after processing.",name:"AxisComponent",required:!0,type:{name:"FC<AxisProps<Scale>>"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/axis/BaseAxis.tsx#BaseAxis"]={docgenInfo:Z.__docgenInfo,name:"BaseAxis",path:"../visx-xychart/src/components/axis/BaseAxis.tsx#BaseAxis"})}catch(ta){}function z(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function H(e){return(0,m.jsx)(Z,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?z(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):z(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({AxisComponent:I.Z},e))}try{H.displayName="AnimatedAxis",H.__docgenInfo={description:"",displayName:"AnimatedAxis",props:{children:{defaultValue:null,description:"For more control over rendering or to add event handlers to datum, pass a function as children.",name:"children",required:!1,type:{name:"(renderProps: AxisRendererProps<Scale>) => ReactNode"}},stroke:{defaultValue:null,description:"The color for the stroke of the lines.",name:"stroke",required:!1,type:{name:"string"}},orientation:{defaultValue:null,description:"Required axis orientation.",name:"orientation",required:!0,type:{name:'"top" | "left" | "right" | "bottom"'}},strokeDasharray:{defaultValue:null,description:"The pattern of dashes in the stroke.",name:"strokeDasharray",required:!1,type:{name:"string"}},strokeWidth:{defaultValue:null,description:"The pixel value for the width of the lines.",name:"strokeWidth",required:!1,type:{name:"ReactText"}},innerRef:{defaultValue:null,description:"The ref to the outermost axis group element.",name:"innerRef",required:!1,type:{name:"Ref<SVGGElement>"}},top:{defaultValue:null,description:"A top pixel offset applied to the entire axis.",name:"top",required:!1,type:{name:"number"}},left:{defaultValue:null,description:"A left pixel offset applied to the entire axis.",name:"left",required:!1,type:{name:"number"}},hideTicks:{defaultValue:null,description:"If true, will hide the ticks (but not the tick labels).",name:"hideTicks",required:!1,type:{name:"boolean"}},tickClassName:{defaultValue:null,description:"The class name applied to each tick group.",name:"tickClassName",required:!1,type:{name:"string"}},tickComponent:{defaultValue:null,description:"Override the component used to render tick labels (instead of <Text /> from @visx/text).",name:"tickComponent",required:!1,type:{name:"(tickRendererProps: TickRendererProps) => ReactNode"}},tickStroke:{defaultValue:null,description:"The color for the tick's stroke value.",name:"tickStroke",required:!1,type:{name:"string"}},tickTransform:{defaultValue:null,description:"A custom SVG transform value to be applied to each tick group.",name:"tickTransform",required:!1,type:{name:"string"}},tickLineProps:{defaultValue:null,description:"Props to be applied to individual tick lines.",name:"tickLineProps",required:!1,type:{name:'Pick<SVGProps<SVGLineElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | "radius" | "color" | ... 453 more ... | "key">'}},numTicks:{defaultValue:null,description:"The number of ticks wanted for the axis (note this is approximate)",name:"numTicks",required:!1,type:{name:"number"}},tickValues:{defaultValue:null,description:"An array of values that determine the number and values of the ticks. Falls back to `scale.ticks()` or `.domain()`.",name:"tickValues",required:!1,type:{name:"ScaleInput<Scale>[]"}},label:{defaultValue:null,description:"The text for the axis label.",name:"label",required:!1,type:{name:"string"}},ticksComponent:{defaultValue:null,description:"Override the component used to render all tick lines and labels.",name:"ticksComponent",required:!1,type:{name:"(tickRendererProps: TicksRendererProps<Scale>) => ReactNode"}},axisLineClassName:{defaultValue:null,description:"The class name applied to the axis line element.",name:"axisLineClassName",required:!1,type:{name:"string"}},hideAxisLine:{defaultValue:null,description:"If true, will hide the axis line.",name:"hideAxisLine",required:!1,type:{name:"boolean"}},hideZero:{defaultValue:null,description:"If true, will hide the '0' value tick and tick label.",name:"hideZero",required:!1,type:{name:"boolean"}},labelClassName:{defaultValue:null,description:"The class name applied to the axis label text element.",name:"labelClassName",required:!1,type:{name:"string"}},labelOffset:{defaultValue:null,description:"Pixel offset of the axis label (does not include tick label font size, which is accounted for automatically)",name:"labelOffset",required:!1,type:{name:"number"}},labelProps:{defaultValue:null,description:"Props applied to the axis label component.",name:"labelProps",required:!1,type:{name:"Partial<TextProps>"}},rangePadding:{defaultValue:null,description:"Pixel padding to apply to axis sides.",name:"rangePadding",required:!1,type:{name:"number | { start?: number; end?: number; }"}},tickFormat:{defaultValue:null,description:"A [d3 formatter](https://github.com/d3/d3-scale/blob/master/README.md#continuous_tickFormat) for the tick text.",name:"tickFormat",required:!1,type:{name:"TickFormatter<ScaleInput<Scale>>"}},tickLabelProps:{defaultValue:null,description:"Either an object with the props for all tick labels or a function that returns props for a given tick label.",name:"tickLabelProps",required:!1,type:{name:"TickLabelProps<ScaleInput<Scale>>"}},tickLength:{defaultValue:null,description:"The length of the tick lines.",name:"tickLength",required:!1,type:{name:"number"}},axisClassName:{defaultValue:null,description:"The class name applied to the outermost axis group element.",name:"axisClassName",required:!1,type:{name:"string"}},animationTrajectory:{defaultValue:null,description:"Animation trjectory of axis ticks.",name:"animationTrajectory",required:!1,type:{name:"AnimationTrajectory"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/axis/AnimatedAxis.tsx#AnimatedAxis"]={docgenInfo:H.__docgenInfo,name:"AnimatedAxis",path:"../visx-xychart/src/components/axis/AnimatedAxis.tsx#AnimatedAxis"})}catch(ta){}var W=n(18398),U=n(54289),J=["rows","columns","GridRowsComponent","GridColumnsComponent"];function Q(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function $(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Q(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Q(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function ee(e){var t=e.rows,n=void 0===t||t,r=e.columns,i=void 0===r||r,l=e.GridRowsComponent,s=e.GridColumnsComponent,u=(0,o.Z)(e,J),c=(0,a.useContext)(d),p=c.theme,f=c.xScale,h=c.yScale,y=c.margin,v=c.innerWidth,b=c.innerHeight,g=null===p||void 0===p?void 0:p.gridStyles;return(0,m.jsxs)(m.Fragment,{children:[n&&h&&null!=v&&(0,m.jsx)(l,$({left:null===y||void 0===y?void 0:y.left,lineStyle:g,width:v,scale:h},u)),i&&f&&null!=b&&(0,m.jsx)(s,$({top:null===y||void 0===y?void 0:y.top,lineStyle:g,height:b,scale:f},u))]})}try{ee.displayName="BaseGrid",ee.__docgenInfo={description:"Component that handles all",displayName:"BaseGrid",props:{rows:{defaultValue:{value:!0},description:"Whether to render GridRows.",name:"rows",required:!1,type:{name:"boolean"}},columns:{defaultValue:{value:!0},description:"Whether to render GridColumns.",name:"columns",required:!1,type:{name:"boolean"}},GridRowsComponent:{defaultValue:null,description:"Rendered GridRows component which is passed GridRowProps by BaseGrid.",name:"GridRowsComponent",required:!0,type:{name:"FC<AllGridRowsProps<ValueOf<ScaleTypeToD3Scale<BrushScaleOutput, any, any>>>>"}},GridColumnsComponent:{defaultValue:null,description:"Rendered GridColumns component which is passed GridColumnsProps by BaseGrid.",name:"GridColumnsComponent",required:!0,type:{name:"FC<GridColumnsProps<ValueOf<ScaleTypeToD3Scale<BrushScaleOutput, any, any>>>>"}},className:{defaultValue:null,description:"classname to apply to line group element.",name:"className",required:!1,type:{name:"string"}},children:{defaultValue:null,description:"Optionally override rendering of grid lines.",name:"children",required:!1,type:{name:"(props: { lines: GridLines; }) => ReactNode"}},top:{defaultValue:null,description:"Top offset to apply to glyph g element container.",name:"top",required:!1,type:{name:"number"}},left:{defaultValue:null,description:"Left offset to apply to glyph g element container.",name:"left",required:!1,type:{name:"number"}},stroke:{defaultValue:null,description:"Grid line stroke color.",name:"stroke",required:!1,type:{name:"string"}},strokeWidth:{defaultValue:null,description:"Grid line stroke thickness.",name:"strokeWidth",required:!1,type:{name:"ReactText"}},strokeDasharray:{defaultValue:null,description:"Grid line stroke-dasharray attribute.",name:"strokeDasharray",required:!1,type:{name:"string"}},numTicks:{defaultValue:null,description:"Approximate number of grid lines. Approximate due to d3 alogrithm, specify `tickValues` for precise control.",name:"numTicks",required:!1,type:{name:"number"}},lineStyle:{defaultValue:null,description:"Styles to apply as grid line style.",name:"lineStyle",required:!1,type:{name:"CSSProperties"}},offset:{defaultValue:null,description:"Pixel offset to apply as a translation (y- for Rows, x- for Columns) to each grid lines.",name:"offset",required:!1,type:{name:"number"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/grid/BaseGrid.tsx#BaseGrid"]={docgenInfo:ee.__docgenInfo,name:"BaseGrid",path:"../visx-xychart/src/components/grid/BaseGrid.tsx#BaseGrid"})}catch(ta){}var te=["animationTrajectory"];function ne(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function re(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?ne(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):ne(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function ae(e){var t=e.animationTrajectory,n=(0,o.Z)(e,te),r=(0,a.useMemo)((function(){return function(e){return(0,m.jsx)(W.Z,re(re({},e),{},{animationTrajectory:t}))}}),[t]),i=(0,a.useMemo)((function(){return function(e){return(0,m.jsx)(U.Z,re(re({},e),{},{animationTrajectory:t}))}}),[t]);return(0,m.jsx)(ee,re({GridRowsComponent:r,GridColumnsComponent:i},n))}try{ae.displayName="AnimatedGrid",ae.__docgenInfo={description:"",displayName:"AnimatedGrid",props:{children:{defaultValue:null,description:"Optionally override rendering of grid lines.",name:"children",required:!1,type:{name:"(props: { lines: GridLines; }) => ReactNode"}},className:{defaultValue:null,description:"classname to apply to line group element.",name:"className",required:!1,type:{name:"string"}},stroke:{defaultValue:null,description:"Grid line stroke color.",name:"stroke",required:!1,type:{name:"string"}},offset:{defaultValue:null,description:"Pixel offset to apply as a translation (y- for Rows, x- for Columns) to each grid lines.",name:"offset",required:!1,type:{name:"number"}},strokeDasharray:{defaultValue:null,description:"Grid line stroke-dasharray attribute.",name:"strokeDasharray",required:!1,type:{name:"string"}},strokeWidth:{defaultValue:null,description:"Grid line stroke thickness.",name:"strokeWidth",required:!1,type:{name:"ReactText"}},top:{defaultValue:null,description:"Top offset to apply to glyph g element container.",name:"top",required:!1,type:{name:"number"}},left:{defaultValue:null,description:"Left offset to apply to glyph g element container.",name:"left",required:!1,type:{name:"number"}},numTicks:{defaultValue:null,description:"Approximate number of grid lines. Approximate due to d3 alogrithm, specify `tickValues` for precise control.",name:"numTicks",required:!1,type:{name:"number"}},lineStyle:{defaultValue:null,description:"Styles to apply as grid line style.",name:"lineStyle",required:!1,type:{name:"CSSProperties"}},rows:{defaultValue:null,description:"Whether to render GridRows.",name:"rows",required:!1,type:{name:"boolean"}},columns:{defaultValue:null,description:"Whether to render GridColumns.",name:"columns",required:!1,type:{name:"boolean"}},animationTrajectory:{defaultValue:null,description:"Animation trajectory of grid lines.",name:"animationTrajectory",required:!1,type:{name:"AnimationTrajectory"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/grid/AnimatedGrid.tsx#AnimatedGrid"]={docgenInfo:ae.__docgenInfo,name:"AnimatedGrid",path:"../visx-xychart/src/components/grid/AnimatedGrid.tsx#AnimatedGrid"})}catch(ta){}var ie=n(26543);function oe(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function le(e){return(0,m.jsx)(Z,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?oe(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):oe(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({AxisComponent:ie.Z},e))}try{le.displayName="Axis",le.__docgenInfo={description:"",displayName:"Axis",props:{children:{defaultValue:null,description:"For more control over rendering or to add event handlers to datum, pass a function as children.",name:"children",required:!1,type:{name:"(renderProps: AxisRendererProps<Scale>) => ReactNode"}},stroke:{defaultValue:null,description:"The color for the stroke of the lines.",name:"stroke",required:!1,type:{name:"string"}},orientation:{defaultValue:null,description:"Required axis orientation.",name:"orientation",required:!0,type:{name:'"top" | "left" | "right" | "bottom"'}},strokeDasharray:{defaultValue:null,description:"The pattern of dashes in the stroke.",name:"strokeDasharray",required:!1,type:{name:"string"}},strokeWidth:{defaultValue:null,description:"The pixel value for the width of the lines.",name:"strokeWidth",required:!1,type:{name:"ReactText"}},innerRef:{defaultValue:null,description:"The ref to the outermost axis group element.",name:"innerRef",required:!1,type:{name:"Ref<SVGGElement>"}},top:{defaultValue:null,description:"A top pixel offset applied to the entire axis.",name:"top",required:!1,type:{name:"number"}},left:{defaultValue:null,description:"A left pixel offset applied to the entire axis.",name:"left",required:!1,type:{name:"number"}},hideTicks:{defaultValue:null,description:"If true, will hide the ticks (but not the tick labels).",name:"hideTicks",required:!1,type:{name:"boolean"}},tickClassName:{defaultValue:null,description:"The class name applied to each tick group.",name:"tickClassName",required:!1,type:{name:"string"}},tickComponent:{defaultValue:null,description:"Override the component used to render tick labels (instead of <Text /> from @visx/text).",name:"tickComponent",required:!1,type:{name:"(tickRendererProps: TickRendererProps) => ReactNode"}},tickStroke:{defaultValue:null,description:"The color for the tick's stroke value.",name:"tickStroke",required:!1,type:{name:"string"}},tickTransform:{defaultValue:null,description:"A custom SVG transform value to be applied to each tick group.",name:"tickTransform",required:!1,type:{name:"string"}},tickLineProps:{defaultValue:null,description:"Props to be applied to individual tick lines.",name:"tickLineProps",required:!1,type:{name:'Pick<SVGProps<SVGLineElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | "radius" | "color" | ... 453 more ... | "key">'}},numTicks:{defaultValue:null,description:"The number of ticks wanted for the axis (note this is approximate)",name:"numTicks",required:!1,type:{name:"number"}},tickValues:{defaultValue:null,description:"An array of values that determine the number and values of the ticks. Falls back to `scale.ticks()` or `.domain()`.",name:"tickValues",required:!1,type:{name:"ScaleInput<Scale>[]"}},label:{defaultValue:null,description:"The text for the axis label.",name:"label",required:!1,type:{name:"string"}},ticksComponent:{defaultValue:null,description:"Override the component used to render all tick lines and labels.",name:"ticksComponent",required:!1,type:{name:"(tickRendererProps: TicksRendererProps<Scale>) => ReactNode"}},axisLineClassName:{defaultValue:null,description:"The class name applied to the axis line element.",name:"axisLineClassName",required:!1,type:{name:"string"}},hideAxisLine:{defaultValue:null,description:"If true, will hide the axis line.",name:"hideAxisLine",required:!1,type:{name:"boolean"}},hideZero:{defaultValue:null,description:"If true, will hide the '0' value tick and tick label.",name:"hideZero",required:!1,type:{name:"boolean"}},labelClassName:{defaultValue:null,description:"The class name applied to the axis label text element.",name:"labelClassName",required:!1,type:{name:"string"}},labelOffset:{defaultValue:null,description:"Pixel offset of the axis label (does not include tick label font size, which is accounted for automatically)",name:"labelOffset",required:!1,type:{name:"number"}},labelProps:{defaultValue:null,description:"Props applied to the axis label component.",name:"labelProps",required:!1,type:{name:"Partial<TextProps>"}},rangePadding:{defaultValue:null,description:"Pixel padding to apply to axis sides.",name:"rangePadding",required:!1,type:{name:"number | { start?: number; end?: number; }"}},tickFormat:{defaultValue:null,description:"A [d3 formatter](https://github.com/d3/d3-scale/blob/master/README.md#continuous_tickFormat) for the tick text.",name:"tickFormat",required:!1,type:{name:"TickFormatter<ScaleInput<Scale>>"}},tickLabelProps:{defaultValue:null,description:"Either an object with the props for all tick labels or a function that returns props for a given tick label.",name:"tickLabelProps",required:!1,type:{name:"TickLabelProps<ScaleInput<Scale>>"}},tickLength:{defaultValue:null,description:"The length of the tick lines.",name:"tickLength",required:!1,type:{name:"number"}},axisClassName:{defaultValue:null,description:"The class name applied to the outermost axis group element.",name:"axisClassName",required:!1,type:{name:"string"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/axis/Axis.tsx#Axis"]={docgenInfo:le.__docgenInfo,name:"Axis",path:"../visx-xychart/src/components/axis/Axis.tsx#Axis"})}catch(ta){}var se=n(88310),ue=n(37347);function de(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function ce(e){return(0,m.jsx)(ee,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?de(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):de(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({GridRowsComponent:se.default,GridColumnsComponent:ue.default},e))}try{ce.displayName="Grid",ce.__docgenInfo={description:"",displayName:"Grid",props:{children:{defaultValue:null,description:"Optionally override rendering of grid lines.",name:"children",required:!1,type:{name:"(props: { lines: GridLines; }) => ReactNode"}},className:{defaultValue:null,description:"classname to apply to line group element.",name:"className",required:!1,type:{name:"string"}},stroke:{defaultValue:null,description:"Grid line stroke color.",name:"stroke",required:!1,type:{name:"string"}},offset:{defaultValue:null,description:"Pixel offset to apply as a translation (y- for Rows, x- for Columns) to each grid lines.",name:"offset",required:!1,type:{name:"number"}},strokeDasharray:{defaultValue:null,description:"Grid line stroke-dasharray attribute.",name:"strokeDasharray",required:!1,type:{name:"string"}},strokeWidth:{defaultValue:null,description:"Grid line stroke thickness.",name:"strokeWidth",required:!1,type:{name:"ReactText"}},top:{defaultValue:null,description:"Top offset to apply to glyph g element container.",name:"top",required:!1,type:{name:"number"}},left:{defaultValue:null,description:"Left offset to apply to glyph g element container.",name:"left",required:!1,type:{name:"number"}},numTicks:{defaultValue:null,description:"Approximate number of grid lines. Approximate due to d3 alogrithm, specify `tickValues` for precise control.",name:"numTicks",required:!1,type:{name:"number"}},lineStyle:{defaultValue:null,description:"Styles to apply as grid line style.",name:"lineStyle",required:!1,type:{name:"CSSProperties"}},rows:{defaultValue:null,description:"Whether to render GridRows.",name:"rows",required:!1,type:{name:"boolean"}},columns:{defaultValue:null,description:"Whether to render GridColumns.",name:"columns",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/grid/Grid.tsx#Grid"]={docgenInfo:ce.__docgenInfo,name:"Grid",path:"../visx-xychart/src/components/grid/Grid.tsx#Grid"})}catch(ta){}var pe=n(77372),me=n(68209),fe=(0,a.createContext)(null),he=["debounce","detectBounds","horizontalCrosshairStyle","glyphStyle","renderTooltip","renderGlyph","resizeObserverPolyfill","scroll","showDatumGlyph","showHorizontalCrosshair","showSeriesGlyphs","showVerticalCrosshair","snapTooltipToDatumX","snapTooltipToDatumY","verticalCrosshairStyle","zIndex"],ye=["x","y"];function ve(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function be(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?ve(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):ve(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var ge={position:"absolute",pointerEvents:"none",fontSize:0,lineHeight:0},Se={position:"absolute",left:0,top:0,opacity:0,width:0,height:0,pointerEvents:"none"};function Pe(e){var t=((0,a.useContext)(d)||{}).theme;return(0,m.jsx)("circle",be({cx:e.x,cy:e.y,r:e.size,fill:e.color,stroke:null===t||void 0===t?void 0:t.backgroundColor,strokeWidth:1.5,paintOrder:"fill"},e.glyphStyle))}function Oe(e){return(0,m.jsx)(Pe,be({},e))}function xe(e){var t,n,r,i,l,s,u,f,h,y,v,b,g,S=e.debounce,P=e.detectBounds,O=e.horizontalCrosshairStyle,x=e.glyphStyle,E=e.renderTooltip,k=e.renderGlyph,C=void 0===k?Oe:k,w=e.resizeObserverPolyfill,A=e.scroll,D=void 0===A||A,V=e.showDatumGlyph,T=void 0!==V&&V,j=e.showHorizontalCrosshair,q=void 0!==j&&j,B=e.showSeriesGlyphs,_=void 0!==B&&B,Y=e.showVerticalCrosshair,R=void 0!==Y&&Y,L=e.snapTooltipToDatumX,X=void 0!==L&&L,N=e.snapTooltipToDatumY,F=void 0!==N&&N,I=e.verticalCrosshairStyle,G=e.zIndex,K=(0,o.Z)(e,he),M=(0,a.useContext)(d)||{},Z=M.colorScale,z=M.theme,H=M.innerHeight,W=M.innerWidth,U=M.margin,J=M.xScale,Q=M.yScale,$=M.dataRegistry,ee=M.resizeObserverPolyfill,te=(0,a.useContext)(fe),ne=(0,pe.Z)({debounce:S,detectBounds:P,polyfill:ee||w,scroll:D,zIndex:G}),re=ne.containerRef,ae=ne.TooltipInPortal,ie=ne.forceRefreshBounds,oe=(0,a.useCallback)((function(e){var t;re(null!==(t=null===e||void 0===e?void 0:e.parentElement)&&void 0!==t?t:null)}),[re]),le=null!==te&&void 0!==te&&te.tooltipOpen?E(be(be({},te),{},{colorScale:Z})):null,se=(null===te||void 0===te?void 0:te.tooltipOpen)&&null!=le,ue=(0,a.useRef)(!1);(0,a.useEffect)((function(){se&&!ue.current&&ie(),ue.current=se}),[se,ie]);var de=null===te||void 0===te?void 0:te.tooltipLeft,ce=null===te||void 0===te?void 0:te.tooltipTop,ve=J?c(J):0,Pe=Q?c(Q):0,xe=(0,a.useCallback)((function(e,t){var n,r,a=null===$||void 0===$?void 0:$.get(e),i=null===a||void 0===a?void 0:a.xAccessor,o=null===a||void 0===a?void 0:a.yAccessor;return{left:J&&i?null!==(n=Number(J(i(t)))+ve/2)&&void 0!==n?n:0:void 0,top:Q&&o?null!==(r=Number(Q(o(t)))+Pe/2)&&void 0!==r?r:0:void 0}}),[$,ve,Pe,J,Q]),Ee=null===te||void 0===te||null===(t=te.tooltipData)||void 0===t?void 0:t.nearestDatum,ke=null!==(n=null===Ee||void 0===Ee?void 0:Ee.key)&&void 0!==n?n:"";if(se&&Ee&&(X||F)){var Ce=xe(ke,Ee.datum),we=Ce.left,Ae=Ce.top;de=X&&p(we)?we:de,ce=F&&p(Ae)?Ae:ce}var De=[];if(se&&(T||_)){var Ve,Te,je,qe=Number(null!==(Ve=null===x||void 0===x?void 0:x.radius)&&void 0!==Ve?Ve:4);if(_)Object.values(null!==(Te=null===te||void 0===te||null===(je=te.tooltipData)||void 0===je?void 0:je.datumByKey)&&void 0!==Te?Te:{}).forEach((function(e){var t,n,r,a=e.key,i=e.datum,o=e.index,l=null!==(t=null!==(n=null===Z||void 0===Z?void 0:Z(a))&&void 0!==n?n:null===z||void 0===z||null===(r=z.htmlLabel)||void 0===r?void 0:r.color)&&void 0!==t?t:"#222",s=xe(a,i),u=s.left,d=s.top;p(u)&&p(d)&&De.push({key:a,color:l,datum:i,index:o,size:qe,x:u,y:d,glyphStyle:x,isNearestDatum:!!Ee&&Ee.key===a})}));else if(Ee){var Be=xe(ke,Ee.datum),_e=Be.left,Ye=Be.top;if(p(_e)&&p(Ye)){var Re,Le,Xe,Ne,Fe,Ie,Ge=null!==(Re=null!==(Le=null!==(Xe=null!==(Ne=ke&&(null===Z||void 0===Z?void 0:Z(ke)))&&void 0!==Ne?Ne:null)&&void 0!==Xe?Xe:null===z||void 0===z||null===(Fe=z.gridStyles)||void 0===Fe?void 0:Fe.stroke)&&void 0!==Le?Le:null===z||void 0===z||null===(Ie=z.htmlLabel)||void 0===Ie?void 0:Ie.color)&&void 0!==Re?Re:"#222";De.push({key:ke,color:Ge,datum:Ee.datum,index:Ee.index,size:qe,x:_e,y:Ye,glyphStyle:x,isNearestDatum:!0})}}}return(0,m.jsxs)(m.Fragment,{children:[(0,m.jsx)("svg",{ref:oe,style:Se}),se&&(0,m.jsxs)(m.Fragment,{children:[R&&(0,m.jsx)(ae,{className:"visx-crosshair visx-crosshair-vertical",left:de,top:null===U||void 0===U?void 0:U.top,offsetLeft:0,offsetTop:0,detectBounds:!1,style:ge,children:(0,m.jsx)("svg",{width:"1",height:H,overflow:"visible",children:(0,m.jsx)("line",be({x1:0,x2:0,y1:0,y2:H,strokeWidth:1.5,stroke:null!==(r=null!==(i=null===z||void 0===z||null===(l=z.gridStyles)||void 0===l?void 0:l.stroke)&&void 0!==i?i:null===z||void 0===z||null===(s=z.htmlLabel)||void 0===s?void 0:s.color)&&void 0!==r?r:"#222"},I))})}),q&&(0,m.jsx)(ae,{className:"visx-crosshair visx-crosshair-horizontal",left:null===U||void 0===U?void 0:U.left,top:ce,offsetLeft:0,offsetTop:0,detectBounds:!1,style:ge,children:(0,m.jsx)("svg",{width:W,height:"1",overflow:"visible",children:(0,m.jsx)("line",be({x1:0,x2:W,y1:0,y2:0,strokeWidth:1.5,stroke:null!==(u=null!==(f=null===z||void 0===z||null===(h=z.gridStyles)||void 0===h?void 0:h.stroke)&&void 0!==f?f:null===z||void 0===z||null===(y=z.htmlLabel)||void 0===y?void 0:y.color)&&void 0!==u?u:"#222"},O))})}),De.map((function(e,t){var n=e.x,r=e.y,a=(0,o.Z)(e,ye);return(0,m.jsx)(ae,{className:"visx-tooltip-glyph",left:n,top:r,offsetLeft:0,offsetTop:0,detectBounds:!1,style:ge,children:(0,m.jsx)("svg",{overflow:"visible",children:C(be({x:0,y:0},a))})},t)})),(0,m.jsx)(ae,be(be({left:de,top:ce,style:be(be({},me.j),{},{background:null!==(v=null===z||void 0===z?void 0:z.backgroundColor)&&void 0!==v?v:"white",boxShadow:"0 1px 2px ".concat(null!==z&&void 0!==z&&null!==(b=z.htmlLabel)&&void 0!==b&&b.color?"".concat(null===z||void 0===z||null===(g=z.htmlLabel)||void 0===g?void 0:g.color,"55"):"#22222255")},null===z||void 0===z?void 0:z.htmlLabel)},K),{},{children:le}))]})]})}function Ee(e){var t=(0,a.useContext)(fe);return null!==t&&void 0!==t&&t.tooltipOpen?(0,m.jsx)(xe,be({},e)):null}try{Ee.displayName="Tooltip",Ee.__docgenInfo={description:"This is a wrapper component which bails early if tooltip is not visible.\nIf scroll detection is enabled in UseTooltipPortalOptions, this avoids re-rendering\nthe component on every scroll. If many charts with Tooltips are rendered on a page,\nthis also avoids creating many resize observers / hitting browser limits.",displayName:"Tooltip",props:{renderTooltip:{defaultValue:null,description:"When TooltipContext.tooltipOpen=true, this function is invoked and if the\nreturn value is non-null, its content is rendered inside the tooltip container.\nContent will be rendered in an HTML parent.",name:"renderTooltip",required:!0,type:{name:"(params: RenderTooltipParams<Datum>) => ReactNode"}},renderGlyph:{defaultValue:null,description:"Function which handles rendering glyphs.",name:"renderGlyph",required:!1,type:{name:"(params: RenderTooltipGlyphProps<Datum>) => ReactNode"}},snapTooltipToDatumX:{defaultValue:null,description:"Whether to snap tooltip + crosshair x-coord to the nearest Datum x-coord instead of the event x-coord.",name:"snapTooltipToDatumX",required:!1,type:{name:"boolean"}},snapTooltipToDatumY:{defaultValue:null,description:"Whether to snap tooltip + crosshair y-coord to the nearest Datum y-coord instead of the event y-coord.",name:"snapTooltipToDatumY",required:!1,type:{name:"boolean"}},showVerticalCrosshair:{defaultValue:null,description:"Whether to show a vertical line at tooltip position.",name:"showVerticalCrosshair",required:!1,type:{name:"boolean"}},showHorizontalCrosshair:{defaultValue:null,description:"Whether to show a horizontal line at tooltip position.",name:"showHorizontalCrosshair",required:!1,type:{name:"boolean"}},showDatumGlyph:{defaultValue:null,description:"Whether to show a glyph at the tooltip position for the (single) nearest Datum.",name:"showDatumGlyph",required:!1,type:{name:"boolean"}},showSeriesGlyphs:{defaultValue:null,description:"Whether to show a glyph for the nearest Datum in each series.",name:"showSeriesGlyphs",required:!1,type:{name:"boolean"}},verticalCrosshairStyle:{defaultValue:null,description:"Optional styles for the vertical crosshair, if visible.",name:"verticalCrosshairStyle",required:!1,type:{name:"SVGProps<SVGLineElement>"}},horizontalCrosshairStyle:{defaultValue:null,description:"Optional styles for the vertical crosshair, if visible.",name:"horizontalCrosshairStyle",required:!1,type:{name:"SVGProps<SVGLineElement>"}},glyphStyle:{defaultValue:null,description:"Optional styles for the point, if visible.",name:"glyphStyle",required:!1,type:{name:"SVGProps<SVGCircleElement>"}},resizeObserverPolyfill:{defaultValue:null,description:"Tooltip depends on ResizeObserver, which may be polyfilled globally,\npassed to XYChart, or injected into this component.",name:"resizeObserverPolyfill",required:!1,type:{name:"new (cb: ResizeObserverCallback) => ResizeObserver"}},className:{defaultValue:null,description:"Optional className to apply to the Tooltip in addition to `visx-tooltip`.",name:"className",required:!1,type:{name:"string"}},style:{defaultValue:null,description:"Styles to apply, unless `unstyled=true`.",name:"style",required:!1,type:{name:"CSSProperties"}},offsetLeft:{defaultValue:null,description:"Offset the `left` position of the Tooltip by this margin.",name:"offsetLeft",required:!1,type:{name:"number"}},offsetTop:{defaultValue:null,description:"Offset the `top` position of the Tooltip by this margin.",name:"offsetTop",required:!1,type:{name:"number"}},unstyled:{defaultValue:null,description:"Whether to omit applying any style, except `left` / `top`.\nIn most cases if this is `true` a developer must do one of the following\nfor positioning to work correctly:\n- set `applyPositionStyle=true`\n- create a CSS selector like: `.visx-tooltip { position: 'absolute' }`",name:"unstyled",required:!1,type:{name:"boolean"}},applyPositionStyle:{defaultValue:null,description:"Applies position: 'absolute' for tooltips to correctly position themselves\nwhen `unstyled=true`. In a future major release this will be the default behavior.",name:"applyPositionStyle",required:!1,type:{name:"boolean"}},scroll:{defaultValue:null,description:"React to nested scroll changes, don't use this if you know your view is static",name:"scroll",required:!1,type:{name:"boolean"}},zIndex:{defaultValue:null,description:"Optional z-index to set on the Portal.",name:"zIndex",required:!1,type:{name:"ReactText"}},debounce:{defaultValue:null,description:"Debounce resize or scroll events in milliseconds (needed for positioning)",name:"debounce",required:!1,type:{name:"number | { scroll: number; resize: number; }"}},detectBounds:{defaultValue:null,description:"whether TooltipWithBounds should be used to auto-detect (page) boundaries and reposition itself.",name:"detectBounds",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/Tooltip.tsx#Tooltip"]={docgenInfo:Ee.__docgenInfo,name:"Tooltip",path:"../visx-xychart/src/components/Tooltip.tsx#Tooltip"})}catch(ta){}var ke=n(95642),Ce=n(9527),we=(0,a.createContext)(null);function Ae(e,t,n){var r=(0,a.useContext)(we),i=(0,a.useRef)();i.current=n;var o=(0,a.useCallback)((function(e,t,n){r&&r.emit(e,{event:t,svgPoint:(0,Ce.Z)(t),source:n})}),[r]);return(0,a.useEffect)((function(){if(r&&e&&t){var n=function(e){var n;(!i.current||null!==e&&void 0!==e&&e.source&&null!==(n=i.current)&&void 0!==n&&n.includes(e.source))&&t(e)};return r.on(e,n),function(){return null===r||void 0===r?void 0:r.off(e,n)}}}),[r,e,t]),r?o:null}try{Ae.displayName="useEventEmitter",Ae.__docgenInfo={description:"Hook for optionally subscribing to a specified EventType,\nand returns emitter for emitting events.",displayName:"useEventEmitter",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/hooks/useEventEmitter.ts#useEventEmitter"]={docgenInfo:Ae.__docgenInfo,name:"useEventEmitter",path:"../visx-xychart/src/hooks/useEventEmitter.ts#useEventEmitter"})}catch(ta){}var De=n(98705);function Ve(e){var t=e.children,n=(0,a.useMemo)((function(){return(0,De.Z)()}),[]);return(0,m.jsx)(we.Provider,{value:n,children:t})}try{Ve.displayName="EventEmitterProvider",Ve.__docgenInfo={description:"Provider for EventEmitterContext.",displayName:"EventEmitterProvider",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/providers/EventEmitterProvider.tsx#EventEmitterProvider"]={docgenInfo:Ve.__docgenInfo,name:"EventEmitterProvider",path:"../visx-xychart/src/providers/EventEmitterProvider.tsx#EventEmitterProvider"})}catch(ta){}var Te=n(27219),je=n.n(Te),qe=n(37409);function Be(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function _e(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Be(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Be(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Ye(e){var t=e.hideTooltipDebounceMs,n=void 0===t?400:t,r=e.children,o=(0,qe.Z)(void 0),l=o.tooltipOpen,s=o.tooltipLeft,u=o.tooltipTop,d=o.tooltipData,c=o.updateTooltip,f=o.hideTooltip,h=(0,a.useRef)(null);function y(){h.current&&(h.current.cancel(),h.current=null)}(0,a.useEffect)((function(){return y}),[]);var v=(0,a.useRef)((function(e){var t=e.svgPoint,n=e.index,r=e.key,a=e.datum,o=e.distanceX,l=e.distanceY;y();var s=p(o)?o:1/0,u=p(l)?l:1/0,d=Math.sqrt(Math.pow(s,2)+Math.pow(u,2));c((function(e){var o,l,s=e.tooltipData,u=null!==s&&void 0!==s&&s.nearestDatum&&p(s.nearestDatum.distance)?s.nearestDatum.distance:1/0;return{tooltipOpen:!0,tooltipLeft:null===t||void 0===t?void 0:t.x,tooltipTop:null===t||void 0===t?void 0:t.y,tooltipData:{nearestDatum:(null!==(o=null===s||void 0===s||null===(l=s.nearestDatum)||void 0===l?void 0:l.key)&&void 0!==o?o:"")!==r&&u<d?null===s||void 0===s?void 0:s.nearestDatum:{key:r,index:n,datum:a,distance:d},datumByKey:_e(_e({},null===s||void 0===s?void 0:s.datumByKey),{},(0,i.Z)({},r,{datum:a,index:n,key:r}))}}}))})),b=(0,a.useCallback)((function(){h.current=je()(f,n),h.current()}),[f,n]),g=(0,a.useMemo)((function(){return{tooltipOpen:l,tooltipLeft:s,tooltipTop:u,tooltipData:d,updateTooltip:c,showTooltip:v.current,hideTooltip:b}}),[b,d,s,l,u,c]);return(0,m.jsx)(fe.Provider,{value:g,children:r})}try{Ye.displayName="TooltipProvider",Ye.__docgenInfo={description:"Simple wrapper around useTooltip, to provide tooltip data via context.",displayName:"TooltipProvider",props:{hideTooltipDebounceMs:{defaultValue:{value:400},description:"Debounce time for when `hideTooltip` is invoked.",name:"hideTooltipDebounceMs",required:!1,type:{name:"number"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/providers/TooltipProvider.tsx#TooltipProvider"]={docgenInfo:Ye.__docgenInfo,name:"TooltipProvider",path:"../visx-xychart/src/providers/TooltipProvider.tsx#TooltipProvider"})}catch(ta){}var Re=n(29566),Le=n(62928),Xe={red:["#fff5f5","#ffe3e3","#ffc9c9","#ffa8a8","#ff8787","#ff6b6b","#fa5252","#f03e3e","#e03131","#c92a2a"],pink:["#fff0f6","#ffdeeb","#fcc2d7","#faa2c1","#f783ac","#f06595","#e64980","#d6336c","#c2255c","#a61e4d"],grape:["#f8f0fc","#f3d9fa","#eebefa","#e599f7","#da77f2","#cc5de8","#be4bdb","#ae3ec9","#9c36b5","#862e9c"],violet:["#f3f0ff","#e5dbff","#d0bfff","#b197fc","#9775fa","#845ef7","#7950f2","#7048e8","#6741d9","#5f3dc4"],indigo:["#edf2ff","#dbe4ff","#bac8ff","#91a7ff","#748ffc","#5c7cfa","#4c6ef5","#4263eb","#3b5bdb","#364fc7"],blue:["#e8f7ff","#ccedff","#a3daff","#72c3fc","#4dadf7","#329af0","#228ae6","#1c7cd6","#1b6ec2","#1862ab"],cyan:["#e3fafc","#c5f6fa","#99e9f2","#66d9e8","#3bc9db","#22b8cf","#15aabf","#1098ad","#0c8599","#0b7285"],teal:["#e6fcf5","#c3fae8","#96f2d7","#63e6be","#38d9a9","#20c997","#12b886","#0ca678","#099268","#087f5b"],green:["#ebfbee","#d3f9d8","#b2f2bb","#8ce99a","#69db7c","#51cf66","#40c057","#37b24d","#2f9e44","#2b8a3e"],lime:["#f4fce3","#e9fac8","#d8f5a2","#c0eb75","#a9e34b","#94d82d","#82c91e","#74b816","#66a80f","#5c940d"],yellow:["#fff9db","#fff3bf","#ffec99","#ffe066","#ffd43b","#fcc419","#fab005","#f59f00","#f08c00","#e67700"],orange:["#fff4e6","#ffe8cc","#ffd8a8","#ffc078","#ffa94d","#ff922b","#fd7e14","#f76707","#e8590c","#d9480f"],gray:["#f8f9fa","#f1f3f5","#e9ecef","#dee2e6","#ced4da","#adb5bd","#868e96","#495057","#343a40","#212529"]},Ne=Xe.gray,Fe=Ne[7],Ie=[Xe.cyan[9],Xe.cyan[3],Xe.yellow[5],Xe.red[4],Xe.grape[8],Xe.grape[5],Xe.pink[9]],Ge=n(64993);function Ke(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Me(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Ke(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Ke(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var Ze={fontFamily:"-apple-system,BlinkMacSystemFont,Roboto,Helvetica Neue,sans-serif",fontWeight:700,fontSize:12,textAnchor:"middle",pointerEvents:"none",letterSpacing:.4};function ze(e){var t,n,r,a,i,o,l=Me(Me({},Ze),{},{fill:Fe,stroke:"none"},e.svgLabelBig),s=Me(Me({},Ze),{},{fontWeight:200,fontSize:11,fill:Fe,stroke:"none"},e.svgLabelSmall),u=Me(Me({color:null!==(t=null!==(n=null!==(r=null===(a=e.htmlLabel)||void 0===a?void 0:a.color)&&void 0!==r?r:null===(i=e.svgLabelBig)||void 0===i?void 0:i.fill)&&void 0!==n?n:null===(o=e.svgLabelSmall)||void 0===o?void 0:o.fill)&&void 0!==t?t:Fe},Ze),e.htmlLabel);return{backgroundColor:e.backgroundColor,colors:(0,Ge.Z)(e.colors),htmlLabel:Me({},u),svgLabelSmall:Me({},s),svgLabelBig:Me({},l),gridStyles:Me({stroke:e.gridColor,strokeWidth:1},e.gridStyles),axisStyles:{x:{top:{axisLabel:Me(Me({},l),{},{dy:"-0.25em"}),axisLine:Me({stroke:e.gridColorDark,strokeWidth:2},e.xAxisLineStyles),tickLabel:Me(Me({},s),{},{dy:"-0.25em"}),tickLength:e.tickLength,tickLine:Me({strokeWidth:1,stroke:e.gridColor},e.xTickLineStyles)},bottom:{axisLabel:Me(Me({},l),{},{dy:"-0.25em"}),axisLine:Me({stroke:e.gridColorDark,strokeWidth:2},e.xAxisLineStyles),tickLabel:Me(Me({},s),{},{dy:"0.125em"}),tickLength:e.tickLength,tickLine:Me({strokeWidth:1,stroke:e.gridColor},e.xTickLineStyles)}},y:{left:{axisLabel:Me(Me({},l),{},{dx:"-1.25em"}),axisLine:Me({stroke:e.gridColor,strokeWidth:1},e.yAxisLineStyles),tickLabel:Me(Me({},s),{},{textAnchor:"end",dx:"-0.25em",dy:"0.25em"}),tickLength:e.tickLength,tickLine:Me({strokeWidth:1,stroke:e.gridColor},e.yTickLineStyles)},right:{axisLabel:Me(Me({},l),{},{dx:"1.25em"}),axisLine:Me({stroke:e.gridColor,strokeWidth:1},e.yAxisLineStyles),tickLabel:Me(Me({},s),{},{textAnchor:"start",dx:"0.25em",dy:"0.25em"}),tickLength:e.tickLength,tickLine:Me({strokeWidth:1,stroke:e.gridColor},e.yTickLineStyles)}}}}}try{ze.displayName="buildChartTheme",ze.__docgenInfo={description:"Provides a simplified API to build a full XYChartTheme.",displayName:"buildChartTheme",props:{backgroundColor:{defaultValue:null,description:"",name:"backgroundColor",required:!0,type:{name:"string"}},colors:{defaultValue:null,description:"",name:"colors",required:!0,type:{name:"string[]"}},svgLabelBig:{defaultValue:null,description:"",name:"svgLabelBig",required:!1,type:{name:"TextProps"}},svgLabelSmall:{defaultValue:null,description:"",name:"svgLabelSmall",required:!1,type:{name:"TextProps"}},htmlLabel:{defaultValue:null,description:"",name:"htmlLabel",required:!1,type:{name:"CSSProperties"}},xAxisLineStyles:{defaultValue:null,description:"",name:"xAxisLineStyles",required:!1,type:{name:'Pick<SVGAttributes<SVGLineElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | "radius" | ... 455 more ... | "onTransitionEndCapture">'}},yAxisLineStyles:{defaultValue:null,description:"",name:"yAxisLineStyles",required:!1,type:{name:'Pick<SVGAttributes<SVGLineElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | "radius" | ... 455 more ... | "onTransitionEndCapture">'}},xTickLineStyles:{defaultValue:null,description:"",name:"xTickLineStyles",required:!1,type:{name:'Pick<SVGAttributes<SVGLineElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | "radius" | ... 455 more ... | "onTransitionEndCapture">'}},yTickLineStyles:{defaultValue:null,description:"",name:"yTickLineStyles",required:!1,type:{name:'Pick<SVGAttributes<SVGLineElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | "radius" | ... 455 more ... | "onTransitionEndCapture">'}},tickLength:{defaultValue:null,description:"",name:"tickLength",required:!0,type:{name:"number"}},gridColor:{defaultValue:null,description:"",name:"gridColor",required:!0,type:{name:"string"}},gridColorDark:{defaultValue:null,description:"",name:"gridColorDark",required:!0,type:{name:"string"}},gridStyles:{defaultValue:null,description:"",name:"gridStyles",required:!1,type:{name:"CSSProperties"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/theme/buildChartTheme.ts#buildChartTheme"]={docgenInfo:ze.__docgenInfo,name:"buildChartTheme",path:"../visx-xychart/src/theme/buildChartTheme.ts#buildChartTheme"})}catch(ta){}var He=ze({backgroundColor:"#fff",colors:Ie,tickLength:4,svgLabelSmall:{fill:Ne[7]},svgLabelBig:{fill:Ne[9]},gridColor:Ne[5],gridColorDark:Ne[9]}),We=a.createContext(He),Ue=n(66601),Je=n(29931),Qe=function(){function e(){(0,Ue.Z)(this,e),(0,i.Z)(this,"registry",{}),(0,i.Z)(this,"registryKeys",[])}return(0,Je.Z)(e,[{key:"registerData",value:function(e){var t=this;(Array.isArray(e)?e:[e]).forEach((function(e){e.key in t.registry&&null!=t.registry[e.key]&&console.debug("Overriding data registry key",e.key),t.registry[e.key]=e,t.registryKeys=Object.keys(t.registry)}))}},{key:"unregisterData",value:function(e){var t=this;(Array.isArray(e)?e:[e]).forEach((function(e){delete t.registry[e],t.registryKeys=Object.keys(t.registry)}))}},{key:"entries",value:function(){return Object.values(this.registry)}},{key:"get",value:function(e){return this.registry[e]}},{key:"keys",value:function(){return this.registryKeys}}]),e}();try{Qe.displayName="DataRegistry",Qe.__docgenInfo={description:"A class for holding data entries",displayName:"DataRegistry",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/classes/DataRegistry.ts#DataRegistry"]={docgenInfo:Qe.__docgenInfo,name:"DataRegistry",path:"../visx-xychart/src/classes/DataRegistry.ts#DataRegistry"})}catch(ta){}function $e(){var e=(0,a.useState)(Math.random())[1],t=(0,a.useMemo)((function(){return new Qe}),[]);return(0,a.useMemo)((function(){return{registerData:function(){t.registerData.apply(t,arguments),e(Math.random())},unregisterData:function(){t.unregisterData.apply(t,arguments),e(Math.random())},entries:function(){return t.entries()},get:function(e){return t.get(e)},keys:function(){return t.keys()}}}),[t])}try{$e.displayName="useDataRegistry",$e.__docgenInfo={description:"Hook that returns an API equivalent to DataRegistry but which updates as needed for use as a hook.",displayName:"useDataRegistry",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/hooks/useDataRegistry.ts#useDataRegistry"]={docgenInfo:$e.__docgenInfo,name:"useDataRegistry",path:"../visx-xychart/src/hooks/useDataRegistry.ts#useDataRegistry"})}catch(ta){}var et={width:0,height:0,margin:{top:0,right:0,bottom:0,left:0}};function tt(e){var t=(0,a.useState)({width:null==(null===e||void 0===e?void 0:e.width)?et.width:e.width,height:null==(null===e||void 0===e?void 0:e.height)?et.height:e.height,margin:null==(null===e||void 0===e?void 0:e.margin)?et.margin:e.margin}),n=t[0],r=t[1],i=(0,a.useCallback)((function(e){e.width===n.width&&e.height===n.height&&e.margin.left===n.margin.left&&e.margin.right===n.margin.right&&e.margin.top===n.margin.top&&e.margin.bottom===n.margin.bottom||r(e)}),[n.width,n.height,n.margin.left,n.margin.right,n.margin.bottom,n.margin.top]);return[n,i]}try{tt.displayName="useDimensions",tt.__docgenInfo={description:"A hook for accessing and setting memoized width, height, and margin chart dimensions.",displayName:"useDimensions",props:{width:{defaultValue:null,description:"",name:"width",required:!1,type:{name:"number"}},height:{defaultValue:null,description:"",name:"height",required:!1,type:{name:"number"}},margin:{defaultValue:null,description:"",name:"margin",required:!1,type:{name:"{ top: number; right: number; bottom: number; left: number; }"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/hooks/useDimensions.ts#useDimensions"]={docgenInfo:tt.__docgenInfo,name:"useDimensions",path:"../visx-xychart/src/hooks/useDimensions.ts#useDimensions"})}catch(ta){}var nt=n(54556),rt=n(34207),at=n(54048);function it(e){return"band"===(null===e||void 0===e?void 0:e.type)||"ordinal"===(null===e||void 0===e?void 0:e.type)||"point"===(null===e||void 0===e?void 0:e.type)}try{it.displayName="isDiscreteScale",it.__docgenInfo={description:"",displayName:"isDiscreteScale",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/isDiscreteScale.ts#isDiscreteScale"]={docgenInfo:it.__docgenInfo,name:"isDiscreteScale",path:"../visx-xychart/src/utils/isDiscreteScale.ts#isDiscreteScale"})}catch(ta){}function ot(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function lt(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?ot(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):ot(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function st(e){var t=e.dataRegistry,n=e.xRange,r=e.xScaleConfig,i=e.yRange,o=e.yScaleConfig,l=t.keys(),s=(0,Re.Z)(n,2),u=s[0],d=s[1],c=(0,Re.Z)(i,2),p=c[0],m=c[1];return{xScale:(0,a.useMemo)((function(){var e=l.map((function(e){return t.get(e)})),n=e.reduce((function(e,t){return t?e.concat(t.data.map((function(e){return t.xAccessor(e)}))):e}),[]);if(0!==n.length){var a=it(r)?n:(0,at.Z)(n),i=(0,nt.Z)(r)?(0,rt.Z)(lt({range:[u,d],domain:a,zero:!0},r)):(0,rt.Z)(lt({range:[u,d],domain:a},r));return e.forEach((function(e){null!==e&&void 0!==e&&e.xScale&&(i=e.xScale(i))})),i}}),[t,r,l,u,d]),yScale:(0,a.useMemo)((function(){var e=l.map((function(e){return t.get(e)})),n=e.reduce((function(e,t){return t?e.concat(t.data.map((function(e){return t.yAccessor(e)}))):e}),[]);if(0!==n.length){var r=it(o)?n:(0,at.Z)(n),a=(0,nt.Z)(o)?(0,rt.Z)(lt({range:[p,m],domain:r,zero:!0},o)):(0,rt.Z)(lt({range:[p,m],domain:r},o));return e.forEach((function(e){null!==e&&void 0!==e&&e.yScale&&(a=e.yScale(a))})),a}}),[t,o,l,p,m])}}try{st.displayName="useScales",st.__docgenInfo={description:"A hook for creating memoized x- and y-scales.",displayName:"useScales",props:{xScaleConfig:{defaultValue:null,description:"",name:"xScaleConfig",required:!0,type:{name:"ValueOf<ScaleTypeToScaleConfig<BrushScaleOutput, StringLike, DefaultThresholdInput>>"}},yScaleConfig:{defaultValue:null,description:"",name:"yScaleConfig",required:!0,type:{name:"ValueOf<ScaleTypeToScaleConfig<BrushScaleOutput, StringLike, DefaultThresholdInput>>"}},dataRegistry:{defaultValue:null,description:"",name:"dataRegistry",required:!0,type:{name:'Pick<DataRegistry<XScale, YScale, Datum>, "keys" | "registerData" | "unregisterData" | "entries" | "get">'}},xRange:{defaultValue:null,description:"",name:"xRange",required:!0,type:{name:"[number, number]"}},yRange:{defaultValue:null,description:"",name:"yRange",required:!0,type:{name:"[number, number]"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/hooks/useScales.ts#useScales"]={docgenInfo:st.__docgenInfo,name:"useScales",path:"../visx-xychart/src/hooks/useScales.ts#useScales"})}catch(ta){}function ut(e){var t=e.initialDimensions,n=e.theme,r=e.xScale,i=e.yScale,o=e.children,l=e.horizontal,s=void 0===l?"auto":l,u=e.resizeObserverPolyfill,c=(0,a.useContext)(We),p=n||c,f=tt(t),h=(0,Re.Z)(f,2),y=h[0],v=y.width,b=y.height,g=y.margin,S=h[1],P=Math.max(0,v-g.left-g.right),O=Math.max(0,b-g.top-g.bottom),x=$e(),E=st({dataRegistry:x,xScaleConfig:r,yScaleConfig:i,xRange:[g.left,Math.max(0,v-g.right)],yRange:[Math.max(0,b-g.bottom),g.top]}),k=E.xScale,C=E.yScale,w=x.keys(),A=(0,a.useMemo)((function(){return(0,Le.ZP)({domain:w,range:p.colors})}),[w,p.colors]),D="auto"===s?it(i)||"time"===i.type||"utc"===i.type:s,V=(0,a.useMemo)((function(){return{dataRegistry:x,registerData:x.registerData,unregisterData:x.unregisterData,xScale:k,yScale:C,colorScale:A,theme:p,width:v,height:b,margin:g,innerWidth:P,innerHeight:O,setDimensions:S,horizontal:D,resizeObserverPolyfill:u}}),[A,x,b,D,O,P,g,S,p,v,k,C,u]);return(0,m.jsx)(d.Provider,{value:V,children:o})}try{ut.displayName="DataProvider",ut.__docgenInfo={description:"",displayName:"DataProvider",props:{initialDimensions:{defaultValue:null,description:"",name:"initialDimensions",required:!1,type:{name:"Partial<{ width: number; height: number; margin: { top: number; right: number; bottom: number; left: number; }; }>"}},theme:{defaultValue:null,description:"",name:"theme",required:!1,type:{name:"XYChartTheme"}},xScale:{defaultValue:null,description:"",name:"xScale",required:!0,type:{name:"XScaleConfig"}},yScale:{defaultValue:null,description:"",name:"yScale",required:!0,type:{name:"YScaleConfig"}},horizontal:{defaultValue:null,description:"",name:"horizontal",required:!1,type:{name:'boolean | "auto"'}},resizeObserverPolyfill:{defaultValue:null,description:"Optionally set the resizeObserverPolyfill context, which will be available to\nParentSize, Tooltip, and AnnotationLabel components.",name:"resizeObserverPolyfill",required:!1,type:{name:"ResizeObserverPolyfill"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/providers/DataProvider.tsx#DataProvider"]={docgenInfo:ut.__docgenInfo,name:"DataProvider",path:"../visx-xychart/src/providers/DataProvider.tsx#DataProvider"})}catch(ta){}function dt(e){var t=e.source,n=e.onPointerOut,r=void 0===n||n,i=e.onPointerMove,o=void 0===i||i,l=e.onPointerUp,s=void 0===l||l,u=e.onPointerDown,d=void 0===u||u,c=e.onFocus,p=void 0!==c&&c,m=e.onBlur,f=void 0!==m&&m,h=Ae(),y=(0,a.useCallback)((function(e){return null===h||void 0===h?void 0:h("pointermove",e,t)}),[h,t]),v=(0,a.useCallback)((function(e){return null===h||void 0===h?void 0:h("pointerout",e,t)}),[h,t]),b=(0,a.useCallback)((function(e){return null===h||void 0===h?void 0:h("pointerup",e,t)}),[h,t]),g=(0,a.useCallback)((function(e){return null===h||void 0===h?void 0:h("pointerdown",e,t)}),[h,t]),S=(0,a.useCallback)((function(e){return null===h||void 0===h?void 0:h("focus",e,t)}),[h,t]),P=(0,a.useCallback)((function(e){return null===h||void 0===h?void 0:h("blur",e,t)}),[h,t]);return{onPointerMove:o?y:void 0,onFocus:p?S:void 0,onBlur:f?P:void 0,onPointerOut:r?v:void 0,onPointerUp:s?b:void 0,onPointerDown:d?g:void 0}}try{useEventEmitters.displayName="useEventEmitters",useEventEmitters.__docgenInfo={description:"A hook that simplifies creation of handlers for emitting\npointermove, pointerout, and pointerup events to EventEmitterContext.",displayName:"useEventEmitters",props:{source:{defaultValue:null,description:"Source of the events, e.g., the component name.",name:"source",required:!0,type:{name:"string"}},onBlur:{defaultValue:{value:!1},description:"",name:"onBlur",required:!1,type:{name:"boolean"}},onFocus:{defaultValue:{value:!1},description:"",name:"onFocus",required:!1,type:{name:"boolean"}},onPointerMove:{defaultValue:{value:!0},description:"",name:"onPointerMove",required:!1,type:{name:"boolean"}},onPointerOut:{defaultValue:{value:!0},description:"",name:"onPointerOut",required:!1,type:{name:"boolean"}},onPointerUp:{defaultValue:{value:!0},description:"",name:"onPointerUp",required:!1,type:{name:"boolean"}},onPointerDown:{defaultValue:{value:!0},description:"",name:"onPointerDown",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/hooks/useEventEmitters.ts#useEventEmitters"]={docgenInfo:useEventEmitters.__docgenInfo,name:"useEventEmitters",path:"../visx-xychart/src/hooks/useEventEmitters.ts#useEventEmitters"})}catch(ta){}var ct="XYCHART_EVENT_SOURCE";function pt(e){return!!e&&("clientX"in e||"changedTouches"in e)}function mt(e){return!!e&&!pt(e)}try{pt.displayName="isPointerEvent",pt.__docgenInfo={description:"",displayName:"isPointerEvent",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/typeguards/events.ts#isPointerEvent"]={docgenInfo:pt.__docgenInfo,name:"isPointerEvent",path:"../visx-xychart/src/typeguards/events.ts#isPointerEvent"})}catch(ta){}try{mt.displayName="isFocusEvent",mt.__docgenInfo={description:"",displayName:"isFocusEvent",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/typeguards/events.ts#isFocusEvent"]={docgenInfo:mt.__docgenInfo,name:"isFocusEvent",path:"../visx-xychart/src/typeguards/events.ts#isFocusEvent"})}catch(ta){}var ft=n(16949),ht=n(8270),yt=n(92580);function vt(e){var t,n,r=e.scale,a=e.accessor,i=e.scaledValue,o=e.data,l=r;if("invert"in l&&"function"===typeof l.invert){var s=(0,ft.Z)(a).left,u=Number(l.invert(i)),d=s(o,u),c=o[d-1],p=o[d];n=(t=!c||Math.abs(u-a(c))>Math.abs(u-a(p))?p:c)===c?d-1:d}else{if(!("step"in l)||"undefined"===typeof l.step)return console.warn("[visx/xychart/findNearestDatum] encountered incompatible scale type, bailing"),null;var m=r.domain(),f=r.range().map(Number),h=(0,Ge.Z)(f).sort((function(e,t){return e-t})),y=(0,ht.Z)(h[0],h[1],l.step()),v=(0,yt.Nw)(y,i),b=(f[0]<f[1]?m:m.reverse())[v-1],g=o.findIndex((function(e){return String(a(e))===String(b)}));t=o[g],n=g}return null==t||null==n?null:{datum:t,index:n,distance:Math.abs(Number(l(a(t)))-i)}}try{vt.displayName="findNearestDatumSingleDimension",vt.__docgenInfo={description:"Finds the nearest datum in a single direction (x or y) closest to the specified `scaledValue`.",displayName:"findNearestDatumSingleDimension",props:{scale:{defaultValue:null,description:"",name:"scale",required:!0,type:{name:"Scale"}},accessor:{defaultValue:null,description:"",name:"accessor",required:!0,type:{name:"(d: Datum) => ScaleInput<Scale>"}},scaledValue:{defaultValue:null,description:"",name:"scaledValue",required:!0,type:{name:"number"}},data:{defaultValue:null,description:"",name:"data",required:!0,type:{name:"Datum[]"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/findNearestDatumSingleDimension.ts#findNearestDatumSingleDimension"]={docgenInfo:vt.__docgenInfo,name:"findNearestDatumSingleDimension",path:"../visx-xychart/src/utils/findNearestDatumSingleDimension.ts#findNearestDatumSingleDimension"})}catch(ta){}function bt(e){var t=e.xScale,n=e.xAccessor,r=e.yScale,a=e.yAccessor,i=e.point,o=e.data;if(!i)return null;var l=vt({scale:t,accessor:n,scaledValue:i.x,data:o});return l?{datum:l.datum,index:l.index,distanceX:l.distance,distanceY:Math.abs(Number(r(a(l.datum)))-i.y)}:null}try{bt.displayName="findNearestDatumX",bt.__docgenInfo={description:"",displayName:"findNearestDatumX",props:{dataKey:{defaultValue:null,description:"",name:"dataKey",required:!0,type:{name:"string"}},point:{defaultValue:null,description:"",name:"point",required:!0,type:{name:"{ x: number; y: number; }"}},xAccessor:{defaultValue:null,description:"",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},data:{defaultValue:null,description:"",name:"data",required:!0,type:{name:"Datum[]"}},width:{defaultValue:null,description:"",name:"width",required:!0,type:{name:"number"}},height:{defaultValue:null,description:"",name:"height",required:!0,type:{name:"number"}},xScale:{defaultValue:null,description:"",name:"xScale",required:!0,type:{name:"XScale"}},yScale:{defaultValue:null,description:"",name:"yScale",required:!0,type:{name:"YScale"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/findNearestDatumX.ts#findNearestDatumX"]={docgenInfo:bt.__docgenInfo,name:"findNearestDatumX",path:"../visx-xychart/src/utils/findNearestDatumX.ts#findNearestDatumX"})}catch(ta){}function gt(e){var t=e.yScale,n=e.yAccessor,r=e.xScale,a=e.xAccessor,i=e.point,o=e.data;if(!i)return null;var l=vt({scale:t,accessor:n,scaledValue:i.y,data:o});return l?{datum:l.datum,index:l.index,distanceY:l.distance,distanceX:Math.abs(Number(r(a(l.datum)))-i.x)}:null}try{gt.displayName="findNearestDatumY",gt.__docgenInfo={description:"",displayName:"findNearestDatumY",props:{dataKey:{defaultValue:null,description:"",name:"dataKey",required:!0,type:{name:"string"}},point:{defaultValue:null,description:"",name:"point",required:!0,type:{name:"{ x: number; y: number; }"}},xAccessor:{defaultValue:null,description:"",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},data:{defaultValue:null,description:"",name:"data",required:!0,type:{name:"Datum[]"}},width:{defaultValue:null,description:"",name:"width",required:!0,type:{name:"number"}},height:{defaultValue:null,description:"",name:"height",required:!0,type:{name:"number"}},xScale:{defaultValue:null,description:"",name:"xScale",required:!0,type:{name:"XScale"}},yScale:{defaultValue:null,description:"",name:"yScale",required:!0,type:{name:"YScale"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/findNearestDatumY.ts#findNearestDatumY"]={docgenInfo:gt.__docgenInfo,name:"findNearestDatumY",path:"../visx-xychart/src/utils/findNearestDatumY.ts#findNearestDatumY"})}catch(ta){}function St(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}var Pt="__POINTER_EVENTS_ALL",Ot="__POINTER_EVENTS_NEAREST";function xt(e){var t=e.dataKey,n=e.findNearestDatum,r=e.onBlur,o=e.onFocus,l=e.onPointerMove,s=e.onPointerOut,u=e.onPointerUp,c=e.onPointerDown,p=e.allowedSources,m=(0,a.useContext)(d),f=m.width,h=m.height,y=m.horizontal,v=m.dataRegistry,b=m.xScale,g=m.yScale,S=n||(y?gt:bt),P=(0,a.useCallback)((function(e){var n,r=e||{},a=r.svgPoint,o=r.event,l={},s=null,u=1/0;return e&&o&&a&&f&&h&&b&&g?((t===Ot||t===Pt?null!==(n=null===v||void 0===v?void 0:v.keys())&&void 0!==n?n:[]:Array.isArray(t)?t:[t]).forEach((function(e){var n=null===v||void 0===v?void 0:v.get(e);if(n){var r=S({dataKey:e,data:n.data,height:h,point:a,width:f,xAccessor:n.xAccessor,xScale:b,yAccessor:n.yAccessor,yScale:g});if(r&&(l[e]=function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?St(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):St(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({key:e,svgPoint:a,event:o},r),t===Ot)){var d,c,p=Math.sqrt((null!==(d=r.distanceX)&&void 0!==d?d:Math.pow(1/0,2))+(null!==(c=r.distanceY)&&void 0!==c?c:Math.pow(1/0,2)));s=p<u?l[e]:s,u=Math.min(u,p)}}})),(t===Ot?[s]:t===Pt||Array.isArray(t)?Object.values(l):[l[t]]).filter((function(e){return e}))):[]}),[t,v,b,g,f,h,S]),O=(0,a.useCallback)((function(e){l&&P(e).forEach((function(e){return l(e)}))}),[P,l]),x=(0,a.useCallback)((function(e){u&&P(e).forEach((function(e){return u(e)}))}),[P,u]),E=(0,a.useCallback)((function(e){c&&P(e).forEach((function(e){return c(e)}))}),[P,c]),k=(0,a.useCallback)((function(e){o&&P(e).forEach((function(e){return o(e)}))}),[P,o]),C=(0,a.useCallback)((function(e){var t=null===e||void 0===e?void 0:e.event;t&&pt(t)&&s&&s(t)}),[s]),w=(0,a.useCallback)((function(e){var t=null===e||void 0===e?void 0:e.event;t&&mt(t)&&r&&r(t)}),[r]);Ae("pointermove",l?O:void 0,p),Ae("pointerout",s?C:void 0,p),Ae("pointerup",u?x:void 0,p),Ae("pointerdown",c?E:void 0,p),Ae("focus",o?k:void 0,p),Ae("blur",r?w:void 0,p)}try{useEventHandlers.displayName="useEventHandlers",useEventHandlers.__docgenInfo={description:"Hook that returns PointerEvent handlers that invoke the passed pointer\nhandlers with the nearest datum to the event for the passed dataKey.",displayName:"useEventHandlers",props:{dataKey:{defaultValue:null,description:"Controls whether callbacks are invoked for one or more registered dataKeys, the nearest dataKey, or all dataKeys.",name:"dataKey",required:!0,type:{name:"string | string[]"}},findNearestDatum:{defaultValue:null,description:"Optionally override the findNearestDatum logic.",name:"findNearestDatum",required:!1,type:{name:"(params: NearestDatumArgs<XScale, YScale, Datum>) => { datum: Datum; index: number; distanceX: number; distanceY: number; }"}},onFocus:{defaultValue:null,description:"Callback invoked onFocus for one or more series based on dataKey.",name:"onFocus",required:!1,type:{name:"(params: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked onBlur.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked onPointerMove for one or more series based on dataKey.",name:"onPointerMove",required:!1,type:{name:"(params: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked onPointerOut.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked onPointerUp for one or more series based on dataKey.",name:"onPointerUp",required:!1,type:{name:"(params: EventHandlerParams<Datum>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked onPointerDown for one or more series based on dataKey.",name:"onPointerDown",required:!1,type:{name:"(params: EventHandlerParams<Datum>) => void"}},allowedSources:{defaultValue:null,description:"Valid event sources for which to invoke handlers.",name:"allowedSources",required:!1,type:{name:"string[]"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/hooks/useEventHandlers.ts#useEventHandlers"]={docgenInfo:useEventHandlers.__docgenInfo,name:"useEventHandlers",path:"../visx-xychart/src/hooks/useEventHandlers.ts#useEventHandlers"})}catch(ta){}function Et(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function kt(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Et(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Et(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var Ct={top:50,right:50,bottom:50,left:50},wt=[ct];function At(e){var t=e.accessibilityLabel,n=void 0===t?"XYChart":t,r=e.captureEvents,i=void 0===r||r,o=e.children,l=e.height,s=e.horizontal,u=e.margin,c=void 0===u?Ct:u,p=e.onPointerMove,f=e.onPointerOut,h=e.onPointerUp,y=e.onPointerDown,v=e.pointerEventsDataKey,b=void 0===v?"nearest":v,g=e.theme,S=e.width,P=e.xScale,O=e.yScale,x=e.resizeObserverPolyfill,E=(0,a.useContext)(d),k=E.setDimensions,C=E.resizeObserverPolyfill,w=(0,a.useContext)(fe),A=Ae();(0,a.useEffect)((function(){k&&null!=S&&null!=l&&S>0&&l>0&&k({width:S,height:l,margin:c})}),[k,S,l,c]);var D=dt({source:ct});return xt({dataKey:"nearest"===b?Ot:Pt,onPointerMove:p,onPointerOut:f,onPointerUp:h,onPointerDown:y,allowedSources:wt}),k?null==S||null==l?(0,m.jsx)(ke.Z,{resizeObserverPolyfill:C,children:function(t){return(0,m.jsx)(At,kt(kt({},e),{},{width:null==e.width?t.width:e.width,height:null==e.height?t.height:e.height}))}}):null==w?(0,m.jsx)(Ye,{children:(0,m.jsx)(At,kt({},e))}):null==A?(0,m.jsx)(Ve,{children:(0,m.jsx)(At,kt({},e))}):S<=0||l<=0?(console.info("XYChart has a zero width or height, bailing",{width:S,height:l}),null):(0,m.jsxs)("svg",{width:S,height:l,"aria-label":n,children:[o,i&&(0,m.jsx)("rect",kt({x:c.left,y:c.top,width:S-c.left-c.right,height:l-c.top-c.bottom,fill:"transparent"},D))]}):P&&O?(0,m.jsx)(ut,{xScale:P,yScale:O,theme:g,initialDimensions:{width:S,height:l,margin:c},horizontal:s,resizeObserverPolyfill:x,children:(0,m.jsx)(At,kt({},e))}):(console.warn("[@visx/xychart] XYChart: When no DataProvider is available in context, you must pass xScale & yScale config to XYChart."),null)}try{At.displayName="XYChart",At.__docgenInfo={description:"",displayName:"XYChart",props:{accessibilityLabel:{defaultValue:null,description:"aria-label for the chart svg element.",name:"accessibilityLabel",required:!1,type:{name:"string"}},captureEvents:{defaultValue:null,description:"Whether to capture and dispatch pointer events to EventEmitter context (which e.g., Series subscribe to).",name:"captureEvents",required:!1,type:{name:"boolean"}},width:{defaultValue:null,description:"Total width of the desired chart svg, including margin.",name:"width",required:!1,type:{name:"number"}},height:{defaultValue:null,description:"Total height of the desired chart svg, including margin.",name:"height",required:!1,type:{name:"number"}},margin:{defaultValue:null,description:"Margin to apply around the outside.",name:"margin",required:!1,type:{name:"Margin"}},children:{defaultValue:null,description:"XYChart children (Series, Tooltip, etc.).",name:"children",required:!0,type:{name:"ReactNode"}},theme:{defaultValue:null,description:"If DataContext is not available, XYChart will wrap itself in a DataProvider and set this as the theme.",name:"theme",required:!1,type:{name:"XYChartTheme"}},xScale:{defaultValue:null,description:"If DataContext is not available, XYChart will wrap itself in a DataProvider and set this as the xScale config.",name:"xScale",required:!1,type:{name:"XScaleConfig"}},yScale:{defaultValue:null,description:"If DataContext is not available, XYChart will wrap itself in a DataProvider and set this as the yScale config.",name:"yScale",required:!1,type:{name:"YScaleConfig"}},horizontal:{defaultValue:null,description:"",name:"horizontal",required:!1,type:{name:'boolean | "auto"'}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent _for each Series with pointerEvents={true}_.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events for the nearest Datum to the PointerEvent _for each Series with pointerEvents={true}_.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent _for each Series with pointerEvents={true}_.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent _for each Series with pointerEvents={true}_.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},pointerEventsDataKey:{defaultValue:null,description:"Whether to invoke PointerEvent handlers for all dataKeys, or the nearest dataKey.",name:"pointerEventsDataKey",required:!1,type:{name:'"all" | "nearest"'}},resizeObserverPolyfill:{defaultValue:null,description:"Responsive charts, <Tooltip />, and <AnnotationLabel /> depend on ResizeObserver\nwhich may be polyfilled globally, passed to individual components or injected once\ninto this component.",name:"resizeObserverPolyfill",required:!1,type:{name:"ResizeObserverPolyfill"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/XYChart.tsx#XYChart"]={docgenInfo:At.__docgenInfo,name:"XYChart",path:"../visx-xychart/src/components/XYChart.tsx#XYChart"})}catch(ta){}var Dt=n(27620),Vt=n(4573);function Tt(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function jt(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Tt(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Tt(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function qt(e){return function(t){var n=t.dataKey,r=t.data,i=t.xAccessor,o=t.yAccessor,l=(0,a.useContext)(d),s=l.xScale,u=l.yScale,c=l.dataRegistry;(0,a.useEffect)((function(){return c&&c.registerData({key:n,data:r,xAccessor:i,yAccessor:o}),function(){return null===c||void 0===c?void 0:c.unregisterData(n)}}),[c,n,r,i,o]);var p=null===c||void 0===c?void 0:c.get(n);if(!s||!u||!p)return null;var f=e;return(0,m.jsx)(f,jt(jt({},t),{},{xScale:s,yScale:u,data:p.data,xAccessor:p.xAccessor,yAccessor:p.yAccessor}))}}try{qt.displayName="withRegisteredData",qt.__docgenInfo={description:"An HOC that handles registering the Series's data and renders the\n`BaseSeriesComponent`\n- only if x and y scales are available in context, and\n- overrides `props.data/xAccessor/yAccessor` with the values from context.\nThis is useful for avoiding nasty syntax with undefined scales when using\nhooks, and ensures that data + scales are always matched in the case of\nprop changes, etc.",displayName:"withRegisteredData",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/enhancers/withRegisteredData.tsx#withRegisteredData"]={docgenInfo:qt.__docgenInfo,name:"withRegisteredData",path:"../visx-xychart/src/enhancers/withRegisteredData.tsx#withRegisteredData"})}catch(ta){}function Bt(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"center";return function(r){var a=e(t(r));return p(a)?a+("start"===n?0:c(e))/("center"===n?2:1):NaN}}try{Bt.displayName="getScaledValueFactory",Bt.__docgenInfo={description:"Returns a function that takes a Datum as input and returns a scaled value, correcting for the scale's bandwidth if applicable.",displayName:"getScaledValueFactory",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/getScaledValueFactory.ts#getScaledValueFactory"]={docgenInfo:Bt.__docgenInfo,name:"getScaledValueFactory",path:"../visx-xychart/src/utils/getScaledValueFactory.ts#getScaledValueFactory"})}catch(ta){}function _t(e){var t=e.range().map((function(e){var t;return null!==(t=(0,u.Z)(e))&&void 0!==t?t:0})),n=(0,Re.Z)(t,2),r=n[0],a=n[1],i=null!=r&&null!=a&&a<r,o=e(0),l=i?[a,r]:[r,a],s=(0,Re.Z)(l,2),d=s[0],c=s[1];return i?p(o)?Math.min(Math.max(d,o),c):c:p(o)?Math.max(o,d):d}try{_t.displayName="getScaleBaseline",_t.__docgenInfo={description:"Returns the output value of a scale's baseline value, which is either zero\nor the minimum scale value if its domain doesn't include zero.",displayName:"getScaleBaseline",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/getScaleBaseline.ts#getScaleBaseline"]={docgenInfo:_t.__docgenInfo,name:"getScaleBaseline",path:"../visx-xychart/src/utils/getScaleBaseline.ts#getScaleBaseline"})}catch(ta){}function Yt(e){var t,n=e.dataKey,r=e.enableEvents,i=e.findNearestDatum,o=e.onBlur,l=e.onFocus,s=e.onPointerMove,u=e.onPointerOut,d=e.onPointerUp,c=e.onPointerDown,p=e.source,m=e.allowedSources,f=null!==(t=(0,a.useContext)(fe))&&void 0!==t?t:{},h=f.showTooltip,y=f.hideTooltip,v=(0,a.useCallback)((function(e){h(e),s&&s(e)}),[h,s]),b=(0,a.useCallback)((function(e){h(e),l&&l(e)}),[h,l]),g=(0,a.useCallback)((function(e){y(),e&&u&&u(e)}),[y,u]),S=(0,a.useCallback)((function(e){y(),e&&o&&o(e)}),[y,o]),P=(0,a.useCallback)((function(e){h(e),c&&c(e)}),[h,c]);return xt({dataKey:n,findNearestDatum:i,onBlur:r?S:void 0,onFocus:r?b:void 0,onPointerMove:r?v:void 0,onPointerOut:r?g:void 0,onPointerUp:r?d:void 0,onPointerDown:r?P:void 0,allowedSources:m}),dt({source:p,onBlur:!!o&&r,onFocus:!!l&&r,onPointerMove:!!s&&r,onPointerOut:!!u&&r,onPointerUp:!!d&&r,onPointerDown:!!c&&r})}try{Yt.displayName="useSeriesEvents",Yt.__docgenInfo={description:"This hook simplifies the logic for initializing Series event emitters + handlers.",displayName:"useSeriesEvents",props:{onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},dataKey:{defaultValue:null,description:"Controls whether callbacks are invoked for one or more registered dataKeys, the nearest dataKey, or all dataKeys.",name:"dataKey",required:!0,type:{name:"string | string[]"}},allowedSources:{defaultValue:null,description:"Valid event sources for which to invoke handlers.",name:"allowedSources",required:!1,type:{name:"string[]"}},findNearestDatum:{defaultValue:null,description:"Optionally override the findNearestDatum logic.",name:"findNearestDatum",required:!1,type:{name:"(params: NearestDatumArgs<XScale, YScale, Datum>) => { datum: Datum; index: number; distanceX: number; distanceY: number; }"}},source:{defaultValue:null,description:"The source of emitted events.",name:"source",required:!0,type:{name:"string"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/hooks/useSeriesEvents.ts#useSeriesEvents"]={docgenInfo:Yt.__docgenInfo,name:"useSeriesEvents",path:"../visx-xychart/src/hooks/useSeriesEvents.ts#useSeriesEvents"})}catch(ta){}function Rt(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Lt(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Rt(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Rt(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Xt(e){var t,n,r,i=e.colorAccessor,o=e.data,l=e.dataKey,s=e.onBlur,u=e.onFocus,c=e.onPointerMove,f=e.onPointerOut,h=e.onPointerUp,y=e.onPointerDown,v=e.enableEvents,b=void 0===v||v,g=e.renderGlyphs,S=e.size,P=void 0===S?8:S,O=e.xAccessor,x=e.xScale,E=e.yAccessor,k=e.yScale,C=(0,a.useContext)(d),w=C.colorScale,A=C.theme,D=C.horizontal,V=(0,a.useMemo)((function(){return Bt(x,O)}),[x,O]),T=(0,a.useMemo)((function(){return Bt(k,E)}),[k,E]),j=null!==(t=null!==(n=null===w||void 0===w?void 0:w(l))&&void 0!==n?n:null===A||void 0===A||null===(r=A.colors)||void 0===r?void 0:r[0])&&void 0!==t?t:"#222",q="".concat("GLYPHSERIES_EVENT_SOURCE","-").concat(l),B=Yt({dataKey:l,enableEvents:b,onBlur:s,onFocus:u,onPointerMove:c,onPointerOut:f,onPointerUp:h,onPointerDown:y,source:q,allowedSources:[ct,q]}),_=(0,a.useMemo)((function(){return o.map((function(e,t){var n,r=V(e);if(!p(r))return null;var a=T(e);return p(a)?{key:"".concat(t),x:r,y:a,color:null!==(n=null===i||void 0===i?void 0:i(e,t))&&void 0!==n?n:j,size:"function"===typeof P?P(e):P,datum:e}:null})).filter((function(e){return e}))}),[j,i,o,V,T,P]);return(0,m.jsx)(m.Fragment,{children:g(Lt({glyphs:_,xScale:x,yScale:k,horizontal:D},B))})}var Nt=qt(Xt);try{Xt.displayName="BaseGlyphSeries",Xt.__docgenInfo={description:"",displayName:"BaseGlyphSeries",props:{dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},size:{defaultValue:null,description:"The size of a `Glyph`, a `number` or a function which takes a `Datum` and returns a `number`.",name:"size",required:!1,type:{name:"number | ((d: object) => number)"}},colorAccessor:{defaultValue:null,description:"Given a Datum, returns its color. Falls back to theme color if unspecified or if a null-ish value is returned.",name:"colorAccessor",required:!1,type:{name:"(d: object, index: number) => string"}},renderGlyphs:{defaultValue:null,description:"Function which handles rendering glyphs.",name:"renderGlyphs",required:!0,type:{name:"(glyphsProps: GlyphsProps<ValueOf<ScaleTypeToD3Scale<BrushScaleOutput, any, any>>, ValueOf<ScaleTypeToD3Scale<BrushScaleOutput, any, any>>, object>) => ReactNode"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/BaseGlyphSeries.tsx#BaseGlyphSeries"]={docgenInfo:Xt.__docgenInfo,name:"BaseGlyphSeries",path:"../visx-xychart/src/components/series/private/BaseGlyphSeries.tsx#BaseGlyphSeries"})}catch(ta){}function Ft(e){var t=e.key,n=e.color,r=e.x,a=e.y,i=e.size,o=e.onBlur,l=e.onFocus,s=e.onPointerMove,u=e.onPointerOut,d=e.onPointerUp;return(0,m.jsx)("circle",{className:"visx-circle-glyph",tabIndex:o||l?0:void 0,fill:n,r:i/2,cx:r,cy:a,onBlur:o,onFocus:l,onPointerMove:s,onPointerOut:u,onPointerUp:d},t)}try{Ft.displayName="defaultRenderGlyph",Ft.__docgenInfo={description:"",displayName:"defaultRenderGlyph",props:{key:{defaultValue:null,description:"Unique key for Glyph (not dataKey).",name:"key",required:!0,type:{name:"string"}},datum:{defaultValue:null,description:"Datum for Glyph.",name:"datum",required:!0,type:{name:"Datum"}},index:{defaultValue:null,description:"Index of Datum in data array.",name:"index",required:!0,type:{name:"number"}},x:{defaultValue:null,description:"X coordinate of Glyph.",name:"x",required:!0,type:{name:"number"}},y:{defaultValue:null,description:"Y coordinate of Glyph.",name:"y",required:!0,type:{name:"number"}},size:{defaultValue:null,description:"Size of Glyph.",name:"size",required:!0,type:{name:"number"}},color:{defaultValue:null,description:"Color of Glyph.",name:"color",required:!0,type:{name:"string"}},onBlur:{defaultValue:null,description:"Callback to invoke for onBlur.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onFocus:{defaultValue:null,description:"Callback to invoke for onFocus.",name:"onFocus",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerMove:{defaultValue:null,description:"Callback to invoke for onPointerMove.",name:"onPointerMove",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},onPointerOut:{defaultValue:null,description:"Callback to invoke for onPointerOut.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},onPointerUp:{defaultValue:null,description:"Callback to invoke for onPointerUp.",name:"onPointerUp",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/defaultRenderGlyph.tsx#defaultRenderGlyph"]={docgenInfo:Ft.__docgenInfo,name:"defaultRenderGlyph",path:"../visx-xychart/src/components/series/private/defaultRenderGlyph.tsx#defaultRenderGlyph"})}catch(ta){}var It=["PathComponent","curve","data","dataKey","lineProps","onBlur","onFocus","onPointerMove","onPointerOut","onPointerUp","onPointerDown","enableEvents","renderLine","xAccessor","x0Accessor","xScale","yAccessor","y0Accessor","yScale"];function Gt(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Kt(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Gt(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Gt(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Mt(e){var t,n,r,i=e.PathComponent,l=void 0===i?"path":i,s=e.curve,u=e.data,c=e.dataKey,f=e.lineProps,h=e.onBlur,y=e.onFocus,v=e.onPointerMove,b=e.onPointerOut,g=e.onPointerUp,S=e.onPointerDown,P=e.enableEvents,O=void 0===P||P,x=e.renderLine,E=void 0===x||x,k=e.xAccessor,C=e.x0Accessor,w=e.xScale,A=e.yAccessor,D=e.y0Accessor,V=e.yScale,T=(0,o.Z)(e,It),j=(0,a.useContext)(d),q=j.colorScale,B=j.theme,_=j.horizontal,Y=(0,a.useMemo)((function(){return C?Bt(w,C):void 0}),[w,C]),R=(0,a.useMemo)((function(){return Bt(w,k)}),[w,k]),L=(0,a.useMemo)((function(){return D?Bt(V,D):void 0}),[V,D]),X=(0,a.useMemo)((function(){return Bt(V,A)}),[V,A]),N=(0,a.useCallback)((function(e){return p(w(k(e)))&&p(V(A(e)))}),[w,k,V,A]),F=null!==(t=null!==(n=null===q||void 0===q?void 0:q(c))&&void 0!==n?n:null===B||void 0===B||null===(r=B.colors)||void 0===r?void 0:r[0])&&void 0!==t?t:"#222",I="".concat("AREASERIES_EVENT_SOURCE","-").concat(c),G=Yt({dataKey:c,enableEvents:O,onBlur:h,onFocus:y,onPointerMove:v,onPointerOut:b,onPointerUp:g,onPointerDown:S,source:I,allowedSources:[ct,I]}),K=(0,a.useMemo)((function(){var e=_t(_?w:V);return _?{x0:null!==Y&&void 0!==Y?Y:e,x1:R,y:X}:{x:R,y0:null!==L&&void 0!==L?L:e,y1:X}}),[w,V,_,R,X,Y,L]),M=Boolean(y||h),Z=(0,a.useCallback)((function(e){var t=e.glyphs;return M?t.map((function(e){return(0,m.jsx)(a.Fragment,{children:Ft(Kt(Kt({},e),{},{color:"transparent",onFocus:G.onFocus,onBlur:G.onBlur}))},e.key)})):null}),[M,G.onFocus,G.onBlur]);return(0,m.jsxs)(m.Fragment,{children:[(0,m.jsx)(Dt.Z,Kt(Kt(Kt({},K),T),{},{curve:s,defined:N,children:function(e){var t=e.path;return(0,m.jsx)(l,Kt(Kt({className:"visx-area",stroke:"transparent",fill:F,strokeLinecap:"round"},T),{},{d:t(u)||""},G))}})),E&&(0,m.jsx)(Vt.Z,Kt(Kt({x:R,y:X,defined:N,curve:s},f),{},{children:function(e){var t=e.path;return(0,m.jsx)(l,Kt(Kt({className:"visx-line",fill:"transparent",stroke:F,strokeWidth:2,pointerEvents:"none",strokeLinecap:"round"},f),{},{d:t(u)||""}))}})),M&&(0,m.jsx)(Xt,{dataKey:c,data:u,xAccessor:k,yAccessor:A,xScale:w,yScale:V,renderGlyphs:Z})]})}var Zt=qt(Mt);try{Mt.displayName="BaseAreaSeries",Mt.__docgenInfo={description:"",displayName:"BaseAreaSeries",props:{dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},curve:{defaultValue:null,description:"Sets the curve factory (from @visx/curve or d3-curve) for the line generator. Defaults to curveLinear.",name:"curve",required:!1,type:{name:"CurveFactory"}},PathComponent:{defaultValue:null,description:"Rendered component which is passed path props by BaseAreaSeries after processing.",name:"PathComponent",required:!1,type:{name:'"path" | FC<Pick<SVGProps<SVGPathElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | ... 457 more ... | "key">>'}},x0Accessor:{defaultValue:null,description:"Optional accessor to override the baseline value of Area shapes per datum (useful to generate band shapes) when chart is rendered horizontally (vertical line). Defaults to the scale zero value, not compatible with AreaStack.",name:"x0Accessor",required:!1,type:{name:"(d: object) => any"}},y0Accessor:{defaultValue:null,description:"Optional accessor to override the baseline value of Area shapes per datum (useful to generate band shapes). Defaults to the scale zero value, not compatible with AreaStack.",name:"y0Accessor",required:!1,type:{name:"(d: object) => any"}},renderLine:{defaultValue:null,description:"Whether to render a Line along value of the Area shape (area is fill only).",name:"renderLine",required:!1,type:{name:"boolean"}},lineProps:{defaultValue:null,description:"Props to be passed to the Line, if rendered.",name:"lineProps",required:!1,type:{name:'Pick<{ data?: object[]; innerRef?: Ref<SVGPathElement>; children?: (args: { path: Line<object>; }) => ReactNode; fill?: string; className?: string; } & LinePathConfig<object> & SVGProps<...>, "string" | ... 467 more ... | "innerRef">'}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/BaseAreaSeries.tsx#BaseAreaSeries"]={docgenInfo:Mt.__docgenInfo,name:"BaseAreaSeries",path:"../visx-xychart/src/components/series/private/BaseAreaSeries.tsx#BaseAreaSeries"})}catch(ta){}function zt(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Ht(e){return(0,m.jsx)(Zt,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?zt(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):zt(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({},e))}try{Ht.displayName="AreaSeries",Ht.__docgenInfo={description:"",displayName:"AreaSeries",props:{curve:{defaultValue:null,description:"Sets the curve factory (from @visx/curve or d3-curve) for the line generator. Defaults to curveLinear.",name:"curve",required:!1,type:{name:"CurveFactory"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: FocusEvent<SVGPathElement>) => void)"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"((event: FocusEvent<Element>) => void) & ((event: FocusEvent<SVGPathElement>) => void)"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"((event: PointerEvent<Element>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},x0Accessor:{defaultValue:null,description:"Optional accessor to override the baseline value of Area shapes per datum (useful to generate band shapes) when chart is rendered horizontally (vertical line). Defaults to the scale zero value, not compatible with AreaStack.",name:"x0Accessor",required:!1,type:{name:"(d: Datum) => ScaleInput<XScale>"}},y0Accessor:{defaultValue:null,description:"Optional accessor to override the baseline value of Area shapes per datum (useful to generate band shapes). Defaults to the scale zero value, not compatible with AreaStack.",name:"y0Accessor",required:!1,type:{name:"(d: Datum) => ScaleInput<YScale>"}},renderLine:{defaultValue:null,description:"Whether to render a Line along value of the Area shape (area is fill only).",name:"renderLine",required:!1,type:{name:"boolean"}},lineProps:{defaultValue:null,description:"Props to be passed to the Line, if rendered.",name:"lineProps",required:!1,type:{name:'Pick<{ data?: Datum[]; innerRef?: Ref<SVGPathElement>; children?: (args: { path: Line<Datum>; }) => ReactNode; fill?: string; className?: string; } & LinePathConfig<...> & SVGProps<...>, "string" | ... 467 more ... | "innerRef">'}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/AreaSeries.tsx#AreaSeries"]={docgenInfo:Ht.__docgenInfo,name:"AreaSeries",path:"../visx-xychart/src/components/series/AreaSeries.tsx#AreaSeries"})}catch(ta){}var Wt=n(58500),Ut=n(568),Jt=n(30482),Qt=n(62536),$t=n(68338),en=function(e){var t;return null===e||void 0===e||null===(t=e.data)||void 0===t?void 0:t.stack},tn=function(e){return((0,Ut.l8)(e)+(0,Ut.xf)(e))/2};function nn(e,t,n){var r=n?[tn,en]:[en,tn],a=(0,Re.Z)(r,2),i=a[0],o=a[1];return e.map((function(e,r){var a={key:e.key,data:e,xAccessor:i,yAccessor:o};return t.length>0&&0===r&&(n?a.xScale=function(e){return e.domain((0,at.Z)(e.domain().concat(t)))}:a.yScale=function(e){return e.domain((0,at.Z)(e.domain().concat(t)))}),a})).filter((function(e){return e}))}try{nn.displayName="getBarStackRegistryData",nn.__docgenInfo={description:"Constructs the `DataRegistryEntry`s for a BarStack, using the stacked data.",displayName:"getBarStackRegistryData",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/getBarStackRegistryData.ts#getBarStackRegistryData"]={docgenInfo:nn.__docgenInfo,name:"getBarStackRegistryData",path:"../visx-xychart/src/utils/getBarStackRegistryData.ts#getBarStackRegistryData"})}catch(ta){}var rn=function(e){return e.stack};function an(e,t){var n={};return e.forEach((function(e){var r=e.props,a=r.dataKey,i=r.data,o=r.xAccessor,l=r.yAccessor;if(o&&l){var s=t?[l,o]:[o,l],u=(0,Re.Z)(s,2),d=u[0],c=u[1];i.forEach((function(e){var t=d(e),r=c(e),i=String(t);n[i]||(n[i]={stack:t,positiveSum:0,negativeSum:0}),n[i][a]=r,n[i][r>=0?"positiveSum":"negativeSum"]+=r}))}})),Object.values(n)}try{an.displayName="combineBarStackData",an.__docgenInfo={description:"Merges `seriesChildren` `props.data` by their `stack` value which\nforms the stack grouping (`x` if vertical, `y` if horizontal)\nand returns `CombinedStackData[]`.",displayName:"combineBarStackData",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/combineBarStackData.ts#combineBarStackData"]={docgenInfo:an.__docgenInfo,name:"combineBarStackData",path:"../visx-xychart/src/utils/combineBarStackData.ts#combineBarStackData"})}catch(ta){}try{rn.displayName="getStackValue",rn.__docgenInfo={description:"Returns the value which forms a stack group.",displayName:"getStackValue",props:{stack:{defaultValue:null,description:"",name:"stack",required:!0,type:{name:"ScaleInput<XScale> | ScaleInput<YScale>"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/combineBarStackData.ts#getStackValue"]={docgenInfo:rn.__docgenInfo,name:"getStackValue",path:"../visx-xychart/src/utils/combineBarStackData.ts#getStackValue"})}catch(ta){}function on(e){return a.Children.toArray(e).flatMap((function(e){return"object"===typeof e&&"props"in e&&e.props.children?e.props.children:e})).filter((function(e){return function(e){return!!e&&"object"===typeof e&&"props"in e&&null!=e.props}(e)}))}try{on.displayName="getChildrenAndGrandchildrenWithProps",on.__docgenInfo={description:"Returns children and grandchildren of type React.ReactNode.\nFlattens children one level to support React.Fragments and Array type children.",displayName:"getChildrenAndGrandchildrenWithProps",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/getChildrenAndGrandchildrenWithProps.ts#getChildrenAndGrandchildrenWithProps"]={docgenInfo:on.__docgenInfo,name:"getChildrenAndGrandchildrenWithProps",path:"../visx-xychart/src/utils/getChildrenAndGrandchildrenWithProps.ts#getChildrenAndGrandchildrenWithProps"})}catch(ta){}function ln(e){var t=e.children,n=e.order,r=e.offset,i=(0,a.useContext)(d),o=i.horizontal,l=i.registerData,s=i.unregisterData,u=(0,a.useMemo)((function(){return on(t)}),[t]),c=(0,a.useMemo)((function(){return u.filter((function(e){return e.props.dataKey})).map((function(e){return e.props.dataKey}))}),[u]),p=(0,a.useMemo)((function(){return an(u,o)}),[o,u]),m=(0,a.useMemo)((function(){var e=r?null:p.some((function(e){return e.negativeSum<0})),t=(0,Jt.Z)();return t.keys(c),n&&t.order((0,$t.default)(n)),(r||e)&&t.offset((0,Qt.default)(r||"diverging")),t(p)}),[p,c,n,r]),f=(0,a.useMemo)((function(){return(0,at.Z)(m.reduce((function(e,t){return t.forEach((function(t){var n=(0,Re.Z)(t,2),r=n[0],a=n[1];e.push(r),e.push(a)})),e}),[]))}),[m]);return(0,a.useEffect)((function(){var e=nn(m,f,o);return l(e),function(){return s(c)}}),[c,f,o,m,l,s,u]),{seriesChildren:u,dataKeys:c,stackedData:m}}try{ln.displayName="useStackedData",ln.__docgenInfo={description:"",displayName:"useStackedData",props:{offset:{defaultValue:null,description:"Sets the stack offset to the pre-defined d3 offset, see https://github.com/d3/d3-shape#stack_offset.",name:"offset",required:!1,type:{name:'"none" | "expand" | "diverging" | "silhouette" | "wiggle"'}},order:{defaultValue:null,description:"Sets the stack order to the pre-defined d3 function, see https://github.com/d3/d3-shape#stack_order.",name:"order",required:!1,type:{name:'"none" | "ascending" | "descending" | "reverse" | "insideout"'}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/hooks/useStackedData.ts#useStackedData"]={docgenInfo:ln.__docgenInfo,name:"useStackedData",path:"../visx-xychart/src/hooks/useStackedData.ts#useStackedData"})}catch(ta){}function sn(e,t,n){var r,a,i,o,l=e.xScale,s=e.yScale,u=e.point,d=(n?gt:bt)(e),c=null==(null===d||void 0===d?void 0:d.index)?null:t[d.index];return d&&c&&u?{index:d.index,datum:c,distanceX:n&&u.x>=(null!==(r=l((0,Ut.l8)(d.datum)))&&void 0!==r?r:1/0)&&u.x<=(null!==(a=l((0,Ut.xf)(d.datum)))&&void 0!==a?a:-1/0)?0:d.distanceX,distanceY:n?d.distanceY:u.y<=(null!==(i=s((0,Ut.l8)(d.datum)))&&void 0!==i?i:-1/0)&&u.y>=(null!==(o=s((0,Ut.xf)(d.datum)))&&void 0!==o?o:1/0)?0:d.distanceY}:null}try{sn.displayName="findNearestStackDatum",sn.__docgenInfo={description:"This is a wrapper around findNearestDatumX/Y for BarStack, accounting for a\nBar's d0 and d1, not just d1 (which findNearestDatum uses). Additionally,\nreturns the BarSeries original `Datum`, not the `BarStackDatum` so\nTooltip typing is correct.",displayName:"findNearestStackDatum",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/findNearestStackDatum.ts#findNearestStackDatum"]={docgenInfo:sn.__docgenInfo,name:"findNearestStackDatum",path:"../visx-xychart/src/utils/findNearestStackDatum.ts#findNearestStackDatum"})}catch(ta){}var un=["data","dataKey","xAccessor","yAccessor","curve","PathComponent","lineProps","renderLine"];function dn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function cn(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?dn(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):dn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var pn=function(e){return e};function mn(e){var t=e.PathComponent,n=void 0===t?"path":t,r=e.children,i=e.curve,l=e.enableEvents,s=void 0===l||l,f=e.offset,h=e.onBlur,y=e.onFocus,v=e.onPointerMove,b=e.onPointerOut,g=e.onPointerUp,S=e.onPointerDown,P=e.order,O=e.renderLine,x=void 0===O||O,E=(0,a.useContext)(d),k=E.colorScale,C=E.dataRegistry,w=E.horizontal,A=E.xScale,D=E.yScale,V=E.theme,T=ln({children:r,order:P,offset:f}),j=T.dataKeys,q=T.seriesChildren,B=T.stackedData,_=(0,a.useMemo)((function(){var e=c(A)/2,t=c(D)/2;return w?{y:function(e){var n;return(null!==(n=(0,u.Z)(D(rn(e.data))))&&void 0!==n?n:0)+t},x0:function(t){var n;return(null!==(n=(0,u.Z)(A((0,Ut.l8)(t))))&&void 0!==n?n:0)+e},x1:function(t){var n;return(null!==(n=(0,u.Z)(A((0,Ut.xf)(t))))&&void 0!==n?n:0)+e},defined:function(e){return p(D(rn(e.data)))&&p(A((0,Ut.xf)(e)))}}:{x:function(t){var n;return(null!==(n=(0,u.Z)(A(rn(t.data))))&&void 0!==n?n:0)+e},y0:function(e){var n;return(null!==(n=(0,u.Z)(D((0,Ut.l8)(e))))&&void 0!==n?n:0)+t},y1:function(e){var n;return(null!==(n=(0,u.Z)(D((0,Ut.xf)(e))))&&void 0!==n?n:0)+t},defined:function(e){return p(A(rn(e.data)))&&p(D((0,Ut.xf)(e)))}}}),[A,D,w]),Y=(0,a.useMemo)((function(){return B.map((function(e,t){var n,r,a,i=q.find((function(t){return t.props.dataKey===e.key})),l=(null===i||void 0===i?void 0:i.props)||{},s=(l.data,l.dataKey,l.xAccessor,l.yAccessor,l.curve,l.PathComponent,l.lineProps),u=(l.renderLine,(0,o.Z)(l,un)),d=cn({fill:null!==(n=null!==(r=null===k||void 0===k?void 0:k(e.key))&&void 0!==r?r:null===V||void 0===V||null===(a=V.colors)||void 0===a?void 0:a[0])&&void 0!==n?n:"#222"},u);return{key:"".concat(t,"-").concat(e.key),accessors:_,data:e,areaProps:d,lineProps:s}}))}),[B,_,k,q,V]),R=(0,a.useCallback)((function(e){var t,n,r=null===(t=q.find((function(t){return t.props.dataKey===e.dataKey})))||void 0===t||null===(n=t.props)||void 0===n?void 0:n.data;return r?sn(e,r,w):null}),[q,w]),L="".concat("AREASTACK_EVENT_SOURCE","-").concat(j.join("-")),X=Yt({dataKey:j,enableEvents:s,findNearestDatum:R,onBlur:h,onFocus:y,onPointerMove:v,onPointerOut:b,onPointerUp:g,onPointerDown:S,source:L,allowedSources:[ct,L]}),N=Boolean(y||h),F=(0,a.useCallback)((function(e){var t=e.glyphs;return N?t.map((function(e){return(0,m.jsx)(a.Fragment,{children:Ft(cn(cn({},e),{},{color:"transparent",onFocus:X.onFocus,onBlur:X.onBlur}))},e.key)})):null}),[N,X.onFocus,X.onBlur]);return!j.some((function(e){return null==C.get(e)}))&&A&&D&&k?(0,m.jsxs)("g",{className:"visx-area-stack",children:[Y.map((function(e){return(0,m.jsx)(Dt.Z,cn(cn({curve:i},e.accessors),{},{children:function(t){var r=t.path;return(0,m.jsx)(n,cn(cn({className:"visx-area",stroke:"transparent",d:r(e.data)||""},e.areaProps),X))}}),e.key)})),x&&Y.map((function(e){return(0,m.jsx)(Wt.Z,cn(cn({x:e.accessors.x||e.accessors.x1,y:e.accessors.y||e.accessors.y1,defined:e.accessors.defined,curve:i},e.lineProps),{},{children:function(t){var r=t.path;return(0,m.jsx)(n,cn(cn({className:"visx-line",fill:"transparent",stroke:e.areaProps.fill,strokeWidth:2,pointerEvents:"none"},e.lineProps),{},{d:r(e.data)||""}))}}),"line-".concat(e.key))})),N&&Y.map((function(e,t){var n=Y[Y.length-t-1];return(0,m.jsx)(Xt,{dataKey:n.key,data:n.data,xAccessor:n.accessors.x||n.accessors.x1,yAccessor:n.accessors.y||n.accessors.y1,xScale:pn,yScale:pn,renderGlyphs:F},"glyphs-".concat(n.key))}))]}):null}var fn=mn;try{mn.displayName="BaseAreaStack",mn.__docgenInfo={description:"",displayName:"BaseAreaStack",props:{children:{defaultValue:null,description:"`AreaSeries` elements, note we can't strictly enforce this with TS yet.",name:"children",required:!0,type:{name:'ReactElement<Pick<BaseAreaSeriesProps<XScale, YScale, Datum>, "string" | "children" | "scale" | "width" | "height" | "dx" | "dy" | "className" | ... 465 more ... | "lineProps">, string | ... 1 more ... | (new (props: any) => Component<...>)> | ReactElement<...>[]'}},PathComponent:{defaultValue:{value:"path"},description:"Rendered component which is passed path props by BaseAreaStack after processing.",name:"PathComponent",required:!1,type:{name:'"path" | FC<Pick<SVGProps<SVGPathElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | ... 457 more ... | "key">>'}},curve:{defaultValue:null,description:"Sets the curve factory (from @visx/curve or d3-curve) for the line generator. Defaults to curveLinear.",name:"curve",required:!1,type:{name:"CurveFactory"}},renderLine:{defaultValue:{value:!0},description:"Whether to render a Line along value of the Area shape (area is fill only).",name:"renderLine",required:!1,type:{name:"boolean"}},offset:{defaultValue:null,description:"Sets the stack offset to the pre-defined d3 offset, see https://github.com/d3/d3-shape#stack_offset.",name:"offset",required:!1,type:{name:'"none" | "expand" | "diverging" | "silhouette" | "wiggle"'}},order:{defaultValue:null,description:"Sets the stack order to the pre-defined d3 function, see https://github.com/d3/d3-shape#stack_order.",name:"order",required:!1,type:{name:'"none" | "ascending" | "descending" | "reverse" | "insideout"'}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},enableEvents:{defaultValue:{value:!0},description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/BaseAreaStack.tsx#BaseAreaStack"]={docgenInfo:mn.__docgenInfo,name:"BaseAreaStack",path:"../visx-xychart/src/components/series/private/BaseAreaStack.tsx#BaseAreaStack"})}catch(ta){}function hn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function yn(e){return(0,m.jsx)(fn,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?hn(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):hn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({},e))}try{yn.displayName="AreaStack",yn.__docgenInfo={description:"",displayName:"AreaStack",props:{children:{defaultValue:null,description:"`AreaSeries` elements, note we can't strictly enforce this with TS yet.",name:"children",required:!0,type:{name:'ReactElement<Pick<BaseAreaSeriesProps<XScale, YScale, Datum>, "string" | "children" | "scale" | "width" | "height" | "dx" | "dy" | "className" | ... 465 more ... | "lineProps">, string | ... 1 more ... | (new (props: any) => Component<...>)> | ReactElement<...>[]'}},curve:{defaultValue:null,description:"Sets the curve factory (from @visx/curve or d3-curve) for the line generator. Defaults to curveLinear.",name:"curve",required:!1,type:{name:"CurveFactory"}},offset:{defaultValue:null,description:"Sets the stack offset to the pre-defined d3 offset, see https://github.com/d3/d3-shape#stack_offset.",name:"offset",required:!1,type:{name:'"none" | "expand" | "diverging" | "silhouette" | "wiggle"'}},order:{defaultValue:null,description:"Sets the stack order to the pre-defined d3 function, see https://github.com/d3/d3-shape#stack_order.",name:"order",required:!1,type:{name:'"none" | "ascending" | "descending" | "reverse" | "insideout"'}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},renderLine:{defaultValue:null,description:"Whether to render a Line along value of the Area shape (area is fill only).",name:"renderLine",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/AreaStack.tsx#AreaStack"]={docgenInfo:yn.__docgenInfo,name:"AreaStack",path:"../visx-xychart/src/components/series/AreaStack.tsx#AreaStack"})}catch(ta){}var vn=n(27069);function bn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function gn(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?bn(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):bn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Sn(e,t,n){var r=e.dataKey,a=e.xAccessor,i=e.yAccessor,o=e.xScale,l=e.yScale,s=e.point,u=(n?gt:bt)(e);if(!u||!s)return null;var d=t(r),c=t.step();if(n){var p=l(i(u.datum)),m=(null!==p&&void 0!==p?p:1/0)+(null!==d&&void 0!==d?d:1/0),f=m+c,h=(m+f)/2,y=s.y>=m&&s.y<=f;return gn(gn({},u),{},{distanceX:0,distanceY:y?0:Math.abs(s.y-h)})}var v=o(a(u.datum)),b=(null!==v&&void 0!==v?v:1/0)+(null!==d&&void 0!==d?d:1/0),g=b+c,S=(b+g)/2,P=s.x>=b&&s.x<=g;return gn(gn({},u),{},{distanceY:0,distanceX:P?0:Math.abs(s.x-S)})}try{Sn.displayName="findNearestGroupDatum",Sn.__docgenInfo={description:"This is a wrapper around findNearestDatumX/Y for BarGroup, accounting for a\nBar's group scale offset (which findNearestDatum does not).",displayName:"findNearestGroupDatum",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/findNearestGroupDatum.ts#findNearestGroupDatum"]={docgenInfo:Sn.__docgenInfo,name:"findNearestGroupDatum",path:"../visx-xychart/src/utils/findNearestGroupDatum.ts#findNearestGroupDatum"})}catch(ta){}function Pn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function On(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Pn(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Pn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function xn(e){var t=e.children,n=e.padding,r=void 0===n?.1:n,i=e.sortBars,o=e.BarsComponent,l=e.onBlur,s=e.onFocus,u=e.onPointerMove,f=e.onPointerOut,h=e.onPointerUp,y=e.onPointerDown,v=e.enableEvents,b=void 0===v||v,g=(0,a.useContext)(d),S=g.colorScale,P=g.dataRegistry,O=g.horizontal,x=g.registerData,E=g.unregisterData,k=g.xScale,C=g.yScale,w=(0,a.useMemo)((function(){return on(t)}),[t]),A=(0,a.useMemo)((function(){return w.map((function(e){var t;return null!==(t=e.props.dataKey)&&void 0!==t?t:""})).filter((function(e){return e}))}),[w]);(0,a.useEffect)((function(){var e=w.map((function(e){var t=e.props;return{key:t.dataKey,data:t.data,xAccessor:t.xAccessor,yAccessor:t.yAccessor}}));return x(e),function(){return E(A)}}),[x,E,w,A]);var D=(0,a.useMemo)((function(){return(0,vn.Z)({domain:i?(0,Ge.Z)(A).sort(i):A,range:[0,c(O?C:k)],padding:r})}),[i,A,k,C,O,r]),V=(0,a.useCallback)((function(e){return Sn(e,D,O)}),[D,O]),T="".concat("BARGROUP_EVENT_SOURCE","-").concat(A.join("-"),"}"),j=Yt({dataKey:A,enableEvents:b,findNearestDatum:V,onBlur:l,onFocus:s,onPointerMove:u,onPointerOut:f,onPointerUp:h,onPointerDown:y,source:T,allowedSources:[ct,T]}),q=(0,a.useMemo)((function(){return k?_t(k):0}),[k]),B=(0,a.useMemo)((function(){return C?_t(C):0}),[C]),_=A.map((function(e){return P.get(e)}));if(_.some((function(e){return null==e}))||!k||!C||!S)return null;var Y=c(D),R=_.map((function(e){var t,n=e.xAccessor,r=e.yAccessor,a=e.data,i=e.key,o=function(e){var t,a;return O?(null!==(t=k(n(e)))&&void 0!==t?t:NaN)-q:(null!==(a=C(r(e)))&&void 0!==a?a:NaN)-B},l=O?function(e){var t;return null!==(t=C(r(e)))&&void 0!==t?t:NaN}:function(e){var t;return null!==(t=k(n(e)))&&void 0!==t?t:NaN},s=null!==(t=D(i))&&void 0!==t?t:0,u=O?function(e){return q+Math.min(0,o(e))}:function(e){return l(e)+s},d=O?function(e){return l(e)+s}:function(e){return B+Math.min(0,o(e))},c=O?function(e){return Math.abs(o(e))}:function(){return Y},m=O?function(){return Y}:function(e){return Math.abs(o(e))},f=w.find((function(e){return e.props.dataKey===i})),h=(null===f||void 0===f?void 0:f.props)||{},y=h.colorAccessor,v=h.radius,b=h.radiusAll,g=h.radiusBottom,P=h.radiusLeft,x=h.radiusRight,E=h.radiusTop;return{key:i,radius:v,radiusAll:b,radiusBottom:g,radiusLeft:P,radiusRight:x,radiusTop:E,bars:a.map((function(e,t){var n,r=u(e);if(!p(r))return null;var a=d(e);if(!p(a))return null;var o=c(e);if(!p(o))return null;var l=m(e);return p(l)?{key:"".concat(i,"-").concat(t),x:r,y:a,width:o,height:l,fill:null!==(n=null===y||void 0===y?void 0:y(e,t))&&void 0!==n?n:S(i)}:null})).filter((function(e){return e}))}}));return(0,m.jsx)("g",{className:"visx-bar-group",children:R.map((function(e){return e&&(0,a.createElement)(o,On(On(On({horizontal:O,xScale:k,yScale:C},e),j),{},{key:e.key}))}))})}try{xn.displayName="BaseBarGroup",xn.__docgenInfo={description:"",displayName:"BaseBarGroup",props:{children:{defaultValue:null,description:"`BarSeries` elements",name:"children",required:!0,type:{name:"ReactNode"}},padding:{defaultValue:{value:.1},description:"Group band scale padding, [0, 1] where 0 = no padding, 1 = no bar.",name:"padding",required:!1,type:{name:"number"}},sortBars:{defaultValue:null,description:"Comparator function to sort `dataKeys` within a bar group. By default the DOM rendering order of `BarGroup`s `children` is used.",name:"sortBars",required:!1,type:{name:"(dataKeyA: string, dataKeyB: string) => number"}},BarsComponent:{defaultValue:null,description:"Rendered component which is passed BarsProps by BaseBarGroup after processing.",name:"BarsComponent",required:!0,type:{name:"FC<BarsProps<XScale, YScale>>"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},enableEvents:{defaultValue:{value:!0},description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/BaseBarGroup.tsx#BaseBarGroup"]={docgenInfo:xn.__docgenInfo,name:"BaseBarGroup",path:"../visx-xychart/src/components/series/private/BaseBarGroup.tsx#BaseBarGroup"})}catch(ta){}var En=n(11742),kn=["bars","horizontal","xScale","yScale","radius","radiusAll","radiusTop","radiusRight","radiusBottom","radiusLeft"],Cn=["key"];function wn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function An(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?wn(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):wn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Dn(e){var t=e.bars,n=(e.horizontal,e.xScale,e.yScale,e.radius),r=e.radiusAll,a=e.radiusTop,i=e.radiusRight,l=e.radiusBottom,s=e.radiusLeft,u=(0,o.Z)(e,kn),d=Boolean(u.onFocus||u.onBlur);return(0,m.jsx)(m.Fragment,{children:t.map((function(e){var t=e.key,c=(0,o.Z)(e,Cn);return null==n?(0,m.jsx)("rect",An(An({className:"visx-bar",tabIndex:d?0:void 0},c),u),t):(0,m.jsx)(En.Z,An(An({className:"visx-bar",tabIndex:d?0:void 0,radius:n,all:r,top:a,right:i,bottom:l,left:s},c),u),t)}))})}try{Dn.displayName="Bars",Dn.__docgenInfo={description:"",displayName:"Bars",props:{bars:{defaultValue:null,description:"",name:"bars",required:!0,type:{name:"Bar[]"}},xScale:{defaultValue:null,description:"",name:"xScale",required:!0,type:{name:"ValueOf<ScaleTypeToD3Scale<BrushScaleOutput, any, any>>"}},yScale:{defaultValue:null,description:"",name:"yScale",required:!0,type:{name:"ValueOf<ScaleTypeToD3Scale<BrushScaleOutput, any, any>>"}},horizontal:{defaultValue:null,description:"",name:"horizontal",required:!1,type:{name:"boolean"}},radiusAll:{defaultValue:null,description:"Whether to apply radius to all corners.",name:"radiusAll",required:!1,type:{name:"boolean"}},radiusTop:{defaultValue:null,description:"Whether to apply radius to top corners.",name:"radiusTop",required:!1,type:{name:"boolean"}},radiusRight:{defaultValue:null,description:"Whether to apply radius to right corners.",name:"radiusRight",required:!1,type:{name:"boolean"}},radiusBottom:{defaultValue:null,description:"Whether to apply radius to bottom corners.",name:"radiusBottom",required:!1,type:{name:"boolean"}},radiusLeft:{defaultValue:null,description:"Whether to apply radius to left corners.",name:"radiusLeft",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/Bars.tsx#Bars"]={docgenInfo:Dn.__docgenInfo,name:"Bars",path:"../visx-xychart/src/components/series/private/Bars.tsx#Bars"})}catch(ta){}function Vn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Tn(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Vn(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Vn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function jn(e){return(0,m.jsx)(xn,Tn(Tn({},e),{},{BarsComponent:Dn}))}try{jn.displayName="BarGroup",jn.__docgenInfo={description:"",displayName:"BarGroup",props:{children:{defaultValue:null,description:"`BarSeries` elements",name:"children",required:!0,type:{name:"ReactNode"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},padding:{defaultValue:null,description:"Group band scale padding, [0, 1] where 0 = no padding, 1 = no bar.",name:"padding",required:!1,type:{name:"number"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},sortBars:{defaultValue:null,description:"Comparator function to sort `dataKeys` within a bar group. By default the DOM rendering order of `BarGroup`s `children` is used.",name:"sortBars",required:!1,type:{name:"(dataKeyA: string, dataKeyB: string) => number"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/BarGroup.tsx#BarGroup"]={docgenInfo:jn.__docgenInfo,name:"BarGroup",path:"../visx-xychart/src/components/series/BarGroup.tsx#BarGroup"})}catch(ta){}var qn=["BarsComponent","barPadding","colorAccessor","data","dataKey","onBlur","onFocus","onPointerMove","onPointerOut","onPointerUp","onPointerDown","enableEvents","xAccessor","xScale","yAccessor","yScale"];function Bn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function _n(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Bn(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Bn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Yn(e){var t,n,r,i=e.BarsComponent,l=e.barPadding,s=void 0===l?.1:l,u=e.colorAccessor,f=e.data,h=e.dataKey,y=e.onBlur,v=e.onFocus,b=e.onPointerMove,g=e.onPointerOut,S=e.onPointerUp,P=e.onPointerDown,O=e.enableEvents,x=void 0===O||O,E=e.xAccessor,k=e.xScale,C=e.yAccessor,w=e.yScale,A=(0,o.Z)(e,qn),D=(0,a.useContext)(d),V=D.colorScale,T=D.horizontal,j=D.theme,q=D.innerWidth,B=void 0===q?0:q,_=D.innerHeight,Y=void 0===_?0:_,R=(0,a.useMemo)((function(){return Bt(k,E)}),[k,E]),L=(0,a.useMemo)((function(){return Bt(w,C)}),[w,C]),X=c(T?w:k)||function(e,t){return e*(1-Math.min(1,Math.max(0,t)))}((T?Y:B)/f.length,s),N=(0,a.useMemo)((function(){return k?_t(k):0}),[k]),F=(0,a.useMemo)((function(){return w?_t(w):0}),[w]),I=null!==(t=null!==(n=null===V||void 0===V?void 0:V(h))&&void 0!==n?n:null===j||void 0===j||null===(r=j.colors)||void 0===r?void 0:r[0])&&void 0!==t?t:"#222",G=(0,a.useMemo)((function(){var e=T?0:-X/2,t=T?-X/2:0;return f.map((function(n,r){var a,i=R(n)+e;if(!p(i))return null;var o=L(n)+t;if(!p(o))return null;var l=T?i-N:o-F;return p(l)?{key:"".concat(r),x:T?N+Math.min(0,l):i,y:T?o:F+Math.min(0,l),width:T?Math.abs(l):X,height:T?X:Math.abs(l),fill:null!==(a=null===u||void 0===u?void 0:u(n,r))&&void 0!==a?a:I}:null})).filter((function(e){return e}))}),[X,I,u,f,R,L,T,N,F]),K="".concat("BARSERIES_EVENT_SOURCE","-").concat(h),M=Yt({dataKey:h,enableEvents:x,onBlur:y,onFocus:v,onPointerMove:b,onPointerOut:g,onPointerUp:S,onPointerDown:P,source:K,allowedSources:[ct,K]});return(0,m.jsx)("g",{className:"vx-bar-series",children:(0,m.jsx)(i,_n(_n({bars:G,horizontal:T,xScale:k,yScale:w},M),A))})}var Rn=qt(Yn);try{Yn.displayName="BaseBarSeries",Yn.__docgenInfo={description:"",displayName:"BaseBarSeries",props:{dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},radius:{defaultValue:null,description:"Optional radius to apply to bar corners.",name:"radius",required:!1,type:{name:"number"}},BarsComponent:{defaultValue:null,description:"Rendered component which is passed BarsProps by BaseBarSeries after processing.",name:"BarsComponent",required:!0,type:{name:"FC<BarsProps<ValueOf<ScaleTypeToD3Scale<BrushScaleOutput, any, any>>, ValueOf<ScaleTypeToD3Scale<BrushScaleOutput, any, any>>>>"}},radiusAll:{defaultValue:null,description:"Whether to apply radius to all corners.",name:"radiusAll",required:!1,type:{name:"boolean"}},radiusTop:{defaultValue:null,description:"Whether to apply radius to top corners.",name:"radiusTop",required:!1,type:{name:"boolean"}},radiusRight:{defaultValue:null,description:"Whether to apply radius to right corners.",name:"radiusRight",required:!1,type:{name:"boolean"}},radiusBottom:{defaultValue:null,description:"Whether to apply radius to bottom corners.",name:"radiusBottom",required:!1,type:{name:"boolean"}},radiusLeft:{defaultValue:null,description:"Whether to apply radius to left corners.",name:"radiusLeft",required:!1,type:{name:"boolean"}},barPadding:{defaultValue:null,description:"Specify bar padding when bar thickness does not come from a `band` scale.\nAccepted values are [0, 1], 0 = no padding, 1 = no bar, defaults to 0.1.",name:"barPadding",required:!1,type:{name:"number"}},colorAccessor:{defaultValue:null,description:"Given a Datum, returns its color. Falls back to theme color if unspecified or if a null-ish value is returned.",name:"colorAccessor",required:!1,type:{name:"(d: object, index: number) => string"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/BaseBarSeries.tsx#BaseBarSeries"]={docgenInfo:Yn.__docgenInfo,name:"BaseBarSeries",path:"../visx-xychart/src/components/series/private/BaseBarSeries.tsx#BaseBarSeries"})}catch(ta){}var Ln=["colorAccessor"];function Xn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Nn(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Xn(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Xn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Fn(e){var t=e.colorAccessor,n=(0,o.Z)(e,Ln);return(0,m.jsx)(Rn,Nn(Nn({},n),{},{colorAccessor:t,BarsComponent:Dn}))}var In=Fn;try{Fn.displayName="BarSeries",Fn.__docgenInfo={description:"",displayName:"BarSeries",props:{radius:{defaultValue:null,description:"Optional radius to apply to bar corners.",name:"radius",required:!1,type:{name:"number"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},radiusAll:{defaultValue:null,description:"Whether to apply radius to all corners.",name:"radiusAll",required:!1,type:{name:"boolean"}},radiusTop:{defaultValue:null,description:"Whether to apply radius to top corners.",name:"radiusTop",required:!1,type:{name:"boolean"}},radiusRight:{defaultValue:null,description:"Whether to apply radius to right corners.",name:"radiusRight",required:!1,type:{name:"boolean"}},radiusBottom:{defaultValue:null,description:"Whether to apply radius to bottom corners.",name:"radiusBottom",required:!1,type:{name:"boolean"}},radiusLeft:{defaultValue:null,description:"Whether to apply radius to left corners.",name:"radiusLeft",required:!1,type:{name:"boolean"}},barPadding:{defaultValue:null,description:"Specify bar padding when bar thickness does not come from a `band` scale.\nAccepted values are [0, 1], 0 = no padding, 1 = no bar, defaults to 0.1.",name:"barPadding",required:!1,type:{name:"number"}},colorAccessor:{defaultValue:null,description:"Given a Datum, returns its color. Falls back to theme color if unspecified or if a null-ish value is returned.",name:"colorAccessor",required:!1,type:{name:"(d: Datum, index: number) => string"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/BarSeries.tsx#BarSeries"]={docgenInfo:Fn.__docgenInfo,name:"BarSeries",path:"../visx-xychart/src/components/series/BarSeries.tsx#BarSeries"})}catch(ta){}var Gn=n(16553);function Kn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Mn(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Kn(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Kn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Zn(e){var t=e.children,n=e.order,r=e.offset,i=e.BarsComponent,o=e.onBlur,l=e.onFocus,s=e.onPointerMove,u=e.onPointerOut,c=e.onPointerUp,f=e.onPointerDown,h=e.enableEvents,y=void 0===h||h,v=(0,a.useContext)(d),b=v.colorScale,g=v.dataRegistry,S=v.horizontal,P=v.xScale,O=v.yScale,x=ln({children:t,order:n,offset:r}),E=x.seriesChildren,k=x.dataKeys,C=x.stackedData,w=(0,a.useCallback)((function(e){var t,n,r=null===(t=E.find((function(t){return t.props.dataKey===e.dataKey})))||void 0===t||null===(n=t.props)||void 0===n?void 0:n.data;return r?sn(e,r,S):null}),[E,S]),A="".concat("BARSTACK_EVENT_SOURCE","-").concat(k.join("-")),D=Yt({dataKey:k,enableEvents:y,findNearestDatum:w,onBlur:o,onFocus:l,onPointerMove:s,onPointerOut:u,onPointerUp:c,onPointerDown:f,source:A,allowedSources:[ct,A]});if(k.map((function(e){return g.get(e)})).some((function(e){return null==e}))||!P||!O||!b)return null;var V,T,j,q,B=(0,Gn.Z)(S?O:P),_=B/2;S?(V=function(e){var t,n;return(null!==(t=P((0,Ut.xf)(e)))&&void 0!==t?t:NaN)-(null!==(n=P((0,Ut.l8)(e)))&&void 0!==n?n:NaN)},T=function(){return B},j=function(e){return P((0,Ut.l8)(e))},q=function(e){var t;return"bandwidth"in O?O(rn(e.data)):Math.max((null!==(t=O(rn(e.data)))&&void 0!==t?t:NaN)-_)}):(V=function(){return B},T=function(e){var t,n;return(null!==(t=O((0,Ut.l8)(e)))&&void 0!==t?t:NaN)-(null!==(n=O((0,Ut.xf)(e)))&&void 0!==n?n:NaN)},j=function(e){var t;return"bandwidth"in P?P(rn(e.data)):Math.max((null!==(t=P(rn(e.data)))&&void 0!==t?t:NaN)-_)},q=function(e){return O((0,Ut.xf)(e))});var Y=C.map((function(e,t){if(!g.get(e.key))return null;var n=E.find((function(t){return t.props.dataKey===e.key})),r=(null===n||void 0===n?void 0:n.props)||{},a=r.colorAccessor,i=r.radius,o=r.radiusAll,l=r.radiusBottom,s=r.radiusLeft,u=r.radiusRight,d=r.radiusTop;return{key:e.key,radius:i,radiusAll:o,radiusBottom:l,radiusLeft:s,radiusRight:u,radiusTop:d,bars:e.map((function(r,i){var o,l=j(r);if(!p(l))return null;var s=q(r);if(!p(s))return null;var u=V(r);if(!p(u))return null;var d=T(r);if(!p(d))return null;var c=a?null===n||void 0===n||null===(o=n.props)||void 0===o?void 0:o.data[i]:null;return{key:"".concat(t,"-").concat(e.key,"-").concat(i),x:l,y:s,width:u,height:d,fill:c&&a?a(c,i):b(e.key)}})).filter((function(e){return e}))}})).filter((function(e){return e}));return(0,m.jsx)("g",{className:"visx-bar-stack",children:Y.map((function(e){return e&&(0,a.createElement)(i,Mn(Mn(Mn({horizontal:S,xScale:P,yScale:O},e),D),{},{key:e.key}))}))})}var zn=Zn;try{Zn.displayName="BaseBarStack",Zn.__docgenInfo={description:"",displayName:"BaseBarStack",props:{children:{defaultValue:null,description:"`BarSeries` elements, note we can't strictly enforce this with TS yet.",name:"children",required:!0,type:{name:'ReactElement<Pick<BaseBarSeriesProps<XScale, YScale, Datum>, "radius" | "onFocus" | "onBlur" | "onPointerDown" | "onPointerMove" | "onPointerUp" | ... 12 more ... | "colorAccessor">, string | ... 1 more ... | (new (props: any) => Component<...>)> | ReactElement<...>[]'}},BarsComponent:{defaultValue:null,description:"Rendered component which is passed BarsProps by BaseBarStack after processing.",name:"BarsComponent",required:!0,type:{name:"FC<BarsProps<XScale, YScale>>"}},offset:{defaultValue:null,description:"Sets the stack offset to the pre-defined d3 offset, see https://github.com/d3/d3-shape#stack_offset.",name:"offset",required:!1,type:{name:'"none" | "expand" | "diverging" | "silhouette" | "wiggle"'}},order:{defaultValue:null,description:"Sets the stack order to the pre-defined d3 function, see https://github.com/d3/d3-shape#stack_order.",name:"order",required:!1,type:{name:'"none" | "ascending" | "descending" | "reverse" | "insideout"'}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},enableEvents:{defaultValue:{value:!0},description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/BaseBarStack.tsx#BaseBarStack"]={docgenInfo:Zn.__docgenInfo,name:"BaseBarStack",path:"../visx-xychart/src/components/series/private/BaseBarStack.tsx#BaseBarStack"})}catch(ta){}function Hn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Wn(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Hn(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Hn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Un(e){return(0,m.jsx)(zn,Wn(Wn({},e),{},{BarsComponent:Dn}))}try{Un.displayName="BarStack",Un.__docgenInfo={description:"",displayName:"BarStack",props:{children:{defaultValue:null,description:"`BarSeries` elements, note we can't strictly enforce this with TS yet.",name:"children",required:!0,type:{name:'ReactElement<Pick<BaseBarSeriesProps<XScale, YScale, Datum>, "radius" | "onFocus" | "onBlur" | "onPointerDown" | "onPointerMove" | "onPointerUp" | ... 12 more ... | "colorAccessor">, string | ... 1 more ... | (new (props: any) => Component<...>)> | ReactElement<...>[]'}},offset:{defaultValue:null,description:"Sets the stack offset to the pre-defined d3 offset, see https://github.com/d3/d3-shape#stack_offset.",name:"offset",required:!1,type:{name:'"none" | "expand" | "diverging" | "silhouette" | "wiggle"'}},order:{defaultValue:null,description:"Sets the stack order to the pre-defined d3 function, see https://github.com/d3/d3-shape#stack_order.",name:"order",required:!1,type:{name:'"none" | "ascending" | "descending" | "reverse" | "insideout"'}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/BarStack.tsx#BarStack"]={docgenInfo:Un.__docgenInfo,name:"BarStack",path:"../visx-xychart/src/components/series/BarStack.tsx#BarStack"})}catch(ta){}var Jn=["renderGlyph"];function Qn(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function $n(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Qn(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Qn(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function er(e){var t=e.renderGlyph,n=void 0===t?Ft:t,r=(0,o.Z)(e,Jn),i=(0,a.useCallback)((function(e){var t=e.glyphs,r=e.onPointerMove,i=e.onPointerOut,o=e.onPointerUp,l=e.onFocus,s=e.onBlur;return t.map((function(e){return(0,m.jsx)(a.Fragment,{children:n($n($n({},e),{},{onPointerMove:r,onPointerOut:i,onPointerUp:o,onFocus:l,onBlur:s}))},e.key)}))}),[n]);return(0,m.jsx)(Nt,$n($n({},r),{},{renderGlyphs:i}))}try{er.displayName="GlyphSeries",er.__docgenInfo={description:"",displayName:"GlyphSeries",props:{onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},size:{defaultValue:null,description:"The size of a `Glyph`, a `number` or a function which takes a `Datum` and returns a `number`.",name:"size",required:!1,type:{name:"number | ((d: Datum) => number)"}},dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},colorAccessor:{defaultValue:null,description:"Given a Datum, returns its color. Falls back to theme color if unspecified or if a null-ish value is returned.",name:"colorAccessor",required:!1,type:{name:"(d: Datum, index: number) => string"}},renderGlyph:{defaultValue:null,description:"",name:"renderGlyph",required:!1,type:{name:"FC<GlyphProps<Datum>>"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/GlyphSeries.tsx#GlyphSeries"]={docgenInfo:er.__docgenInfo,name:"GlyphSeries",path:"../visx-xychart/src/components/series/GlyphSeries.tsx#GlyphSeries"})}catch(ta){}var tr=["colorAccessor","curve","data","dataKey","onBlur","onFocus","onPointerMove","onPointerOut","onPointerUp","onPointerDown","enableEvents","xAccessor","xScale","yAccessor","yScale","PathComponent"];function nr(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function rr(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?nr(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):nr(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function ar(e){var t,n,r,i=e.colorAccessor,l=e.curve,s=e.data,u=e.dataKey,c=e.onBlur,f=e.onFocus,h=e.onPointerMove,y=e.onPointerOut,v=e.onPointerUp,b=e.onPointerDown,g=e.enableEvents,S=void 0===g||g,P=e.xAccessor,O=e.xScale,x=e.yAccessor,E=e.yScale,k=e.PathComponent,C=void 0===k?"path":k,w=(0,o.Z)(e,tr),A=(0,a.useContext)(d),D=A.colorScale,V=A.theme,T=(0,a.useMemo)((function(){return Bt(O,P)}),[O,P]),j=(0,a.useMemo)((function(){return Bt(E,x)}),[E,x]),q=(0,a.useCallback)((function(e){return p(O(P(e)))&&p(E(x(e)))}),[O,P,E,x]),B=null!==(t=null!==(n=null===D||void 0===D?void 0:D(u))&&void 0!==n?n:null===V||void 0===V||null===(r=V.colors)||void 0===r?void 0:r[0])&&void 0!==t?t:"#222",_="".concat("LINESERIES_EVENT_SOURCE","-").concat(u),Y=Yt({dataKey:u,enableEvents:S,onBlur:c,onFocus:f,onPointerMove:h,onPointerOut:y,onPointerUp:v,onPointerDown:b,source:_,allowedSources:[ct,_]}),R=Boolean(f||c),L=(0,a.useCallback)((function(e){var t=e.glyphs;return R?t.map((function(e){return(0,m.jsx)(a.Fragment,{children:Ft(rr(rr({},e),{},{color:"transparent",onFocus:Y.onFocus,onBlur:Y.onBlur}))},e.key)})):null}),[R,Y.onFocus,Y.onBlur]);return(0,m.jsxs)(m.Fragment,{children:[(0,m.jsx)(Vt.Z,rr(rr({x:T,y:j,defined:q,curve:l},w),{},{children:function(e){var t,n=e.path;return(0,m.jsx)(C,rr(rr({stroke:null!==(t=null===i||void 0===i?void 0:i(u))&&void 0!==t?t:B,strokeWidth:2,fill:"transparent",strokeLinecap:"round"},w),{},{d:n(s)||""},Y))}})),R&&(0,m.jsx)(Xt,{dataKey:u,data:s,xAccessor:P,yAccessor:x,xScale:O,yScale:E,renderGlyphs:L})]})}var ir=qt(ar);try{ar.displayName="BaseLineSeries",ar.__docgenInfo={description:"",displayName:"BaseLineSeries",props:{dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},curve:{defaultValue:null,description:"Sets the curve factory (from @visx/curve or d3-curve) for the line generator. Defaults to curveLinear.",name:"curve",required:!1,type:{name:"CurveFactory | CurveFactoryLineOnly"}},PathComponent:{defaultValue:null,description:"Rendered component which is passed path props by BaseLineSeries after processing.",name:"PathComponent",required:!1,type:{name:'"path" | FC<Pick<SVGProps<SVGPathElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | ... 457 more ... | "key">>'}},colorAccessor:{defaultValue:null,description:"Given a datakey, returns its color. Falls back to theme color if unspecified or if a null-ish value is returned.",name:"colorAccessor",required:!1,type:{name:"(dataKey: string) => string"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/BaseLineSeries.tsx#BaseLineSeries"]={docgenInfo:ar.__docgenInfo,name:"BaseLineSeries",path:"../visx-xychart/src/components/series/private/BaseLineSeries.tsx#BaseLineSeries"})}catch(ta){}function or(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function lr(e){return(0,m.jsx)(ir,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?or(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):or(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({},e))}try{lr.displayName="LineSeries",lr.__docgenInfo={description:"",displayName:"LineSeries",props:{curve:{defaultValue:null,description:"Sets the curve factory (from @visx/curve or d3-curve) for the line generator. Defaults to curveLinear.",name:"curve",required:!1,type:{name:"CurveFactory | CurveFactoryLineOnly"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: FocusEvent<SVGPathElement>) => void)"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"((event: FocusEvent<Element>) => void) & ((event: FocusEvent<SVGPathElement>) => void)"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"((event: PointerEvent<Element>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},colorAccessor:{defaultValue:null,description:"Given a datakey, returns its color. Falls back to theme color if unspecified or if a null-ish value is returned.",name:"colorAccessor",required:!1,type:{name:"(dataKey: string) => string"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/LineSeries.tsx#LineSeries"]={docgenInfo:lr.__docgenInfo,name:"LineSeries",path:"../visx-xychart/src/components/series/LineSeries.tsx#LineSeries"})}catch(ta){}var sr=n(12766),ur=["d","stroke","fill"];function dr(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function cr(e){var t=e.d,n=e.stroke,r=void 0===n?"transparent":n,l=e.fill,s=void 0===l?"transparent":l,u=(0,o.Z)(e,ur),d=(0,a.useRef)(t),c=(0,a.useCallback)(je()((function(e){d.current=e}),50),[]),p=(0,sr.interpolatePath)(d.current,t);c(t);var f=(0,P.useSpring)({from:{t:0},to:{t:1},reset:!0,delay:0}).t,h=(0,P.useSpring)({stroke:r,fill:s});return(0,m.jsx)(P.animated.path,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?dr(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):dr(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({className:"visx-path",d:f.to(p),stroke:h.stroke,fill:h.fill},u))}try{cr.displayName="AnimatedPath",cr.__docgenInfo={description:"",displayName:"AnimatedPath",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/AnimatedPath.tsx#AnimatedPath"]={docgenInfo:cr.__docgenInfo,name:"AnimatedPath",path:"../visx-xychart/src/components/series/private/AnimatedPath.tsx#AnimatedPath"})}catch(ta){}function pr(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function mr(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?pr(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):pr(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function fr(e){return(0,m.jsx)(Zt,mr(mr({},e),{},{PathComponent:cr}))}try{fr.displayName="AnimatedAreaSeries",fr.__docgenInfo={description:"",displayName:"AnimatedAreaSeries",props:{curve:{defaultValue:null,description:"Sets the curve factory (from @visx/curve or d3-curve) for the line generator. Defaults to curveLinear.",name:"curve",required:!1,type:{name:"CurveFactory"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: FocusEvent<SVGPathElement>) => void)"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"((event: FocusEvent<Element>) => void) & ((event: FocusEvent<SVGPathElement>) => void)"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"((event: PointerEvent<Element>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},x0Accessor:{defaultValue:null,description:"Optional accessor to override the baseline value of Area shapes per datum (useful to generate band shapes) when chart is rendered horizontally (vertical line). Defaults to the scale zero value, not compatible with AreaStack.",name:"x0Accessor",required:!1,type:{name:"(d: Datum) => ScaleInput<XScale>"}},y0Accessor:{defaultValue:null,description:"Optional accessor to override the baseline value of Area shapes per datum (useful to generate band shapes). Defaults to the scale zero value, not compatible with AreaStack.",name:"y0Accessor",required:!1,type:{name:"(d: Datum) => ScaleInput<YScale>"}},renderLine:{defaultValue:null,description:"Whether to render a Line along value of the Area shape (area is fill only).",name:"renderLine",required:!1,type:{name:"boolean"}},lineProps:{defaultValue:null,description:"Props to be passed to the Line, if rendered.",name:"lineProps",required:!1,type:{name:'Pick<{ data?: Datum[]; innerRef?: Ref<SVGPathElement>; children?: (args: { path: Line<Datum>; }) => ReactNode; fill?: string; className?: string; } & LinePathConfig<...> & SVGProps<...>, "string" | ... 467 more ... | "innerRef">'}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/AnimatedAreaSeries.tsx#AnimatedAreaSeries"]={docgenInfo:fr.__docgenInfo,name:"AnimatedAreaSeries",path:"../visx-xychart/src/components/series/AnimatedAreaSeries.tsx#AnimatedAreaSeries"})}catch(ta){}function hr(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function yr(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?hr(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):hr(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function vr(e){return(0,m.jsx)(fn,yr(yr({},e),{},{PathComponent:cr}))}try{vr.displayName="AnimatedAreaStack",vr.__docgenInfo={description:"",displayName:"AnimatedAreaStack",props:{children:{defaultValue:null,description:"`AreaSeries` elements, note we can't strictly enforce this with TS yet.",name:"children",required:!0,type:{name:'ReactElement<Pick<BaseAreaSeriesProps<XScale, YScale, Datum>, "string" | "children" | "scale" | "width" | "height" | "dx" | "dy" | "className" | ... 465 more ... | "lineProps">, string | ... 1 more ... | (new (props: any) => Component<...>)> | ReactElement<...>[]'}},curve:{defaultValue:null,description:"Sets the curve factory (from @visx/curve or d3-curve) for the line generator. Defaults to curveLinear.",name:"curve",required:!1,type:{name:"CurveFactory"}},offset:{defaultValue:null,description:"Sets the stack offset to the pre-defined d3 offset, see https://github.com/d3/d3-shape#stack_offset.",name:"offset",required:!1,type:{name:'"none" | "expand" | "diverging" | "silhouette" | "wiggle"'}},order:{defaultValue:null,description:"Sets the stack order to the pre-defined d3 function, see https://github.com/d3/d3-shape#stack_order.",name:"order",required:!1,type:{name:'"none" | "ascending" | "descending" | "reverse" | "insideout"'}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},renderLine:{defaultValue:null,description:"Whether to render a Line along value of the Area shape (area is fill only).",name:"renderLine",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/AnimatedAreaStack.tsx#AnimatedAreaStack"]={docgenInfo:vr.__docgenInfo,name:"AnimatedAreaStack",path:"../visx-xychart/src/components/series/AnimatedAreaStack.tsx#AnimatedAreaStack"})}catch(ta){}var br=function(e){return Boolean(null===e||void 0===e?void 0:e.includes("url("))},gr=function(e){return br(e)?"rgba(0,0,0,0.1)":e};try{br.displayName="colorHasUrl",br.__docgenInfo={description:"",displayName:"colorHasUrl",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/cleanColorString.ts#colorHasUrl"]={docgenInfo:br.__docgenInfo,name:"colorHasUrl",path:"../visx-xychart/src/utils/cleanColorString.ts#colorHasUrl"})}catch(ta){}try{gr.displayName="cleanColor",gr.__docgenInfo={description:"",displayName:"cleanColor",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/utils/cleanColorString.ts#cleanColor"]={docgenInfo:gr.__docgenInfo,name:"cleanColor",path:"../visx-xychart/src/utils/cleanColorString.ts#cleanColor"})}catch(ta){}var Sr=["bars","xScale","yScale","horizontal","radius","radiusAll","radiusTop","radiusRight","radiusBottom","radiusLeft"],Pr=["bars","xScale","yScale","horizontal","radius","radiusAll","radiusTop","radiusRight","radiusBottom","radiusLeft"];function Or(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function xr(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Or(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Or(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Er(e){var t=e.x,n=e.y,r=e.width,a=e.height,i=e.fill;return{x:t,y:n,width:r,height:a,fill:gr(i),opacity:1}}function kr(e){var t=e.bars,n=(e.xScale,e.yScale,e.horizontal,e.radius),r=e.radiusAll,a=e.radiusTop,i=e.radiusRight,l=e.radiusBottom,s=e.radiusLeft,u=(0,o.Z)(e,Sr);return(0,m.jsx)(m.Fragment,{children:t.map((function(e){var t=e.key,o=e.fill,d=e.x,c=e.y,p=e.width,f=e.height;return(0,m.jsx)(En.Z,{x:d,y:c,width:p,height:f,radius:n,all:r,top:a,right:i,bottom:l,left:s,children:function(e){var t=e.path;return(0,m.jsx)(cr,xr({className:"visx-bar visx-bar-rounded",d:t,fill:o},u))}},t)}))})}function Cr(e){var t=e.bars,n=e.xScale,r=e.yScale,i=e.horizontal,l=(e.radius,e.radiusAll,e.radiusTop,e.radiusRight,e.radiusBottom,e.radiusLeft,(0,o.Z)(e,Pr)),s=(0,P.useTransition)(t,xr({},function(e){var t=e.scale,n=!!e.horizontal;return(0,a.useMemo)((function(){var e=_t(t);function r(t){var r=t.x,a=t.y,i=t.width,o=t.height,l=t.fill;return{x:n?null!==e&&void 0!==e?e:0:r,y:n?a:null!==e&&void 0!==e?e:0,width:n?0:i,height:n?o:0,fill:gr(l),opacity:0}}return{unique:!0,from:r,leave:r,enter:Er,update:Er,keys:function(e){return e.key}}}),[t,n])}({horizontal:i,scale:i?n:r}))),u=Boolean(l.onFocus||l.onBlur);return(0,m.jsx)(m.Fragment,{children:s((function(e,t,n){var r=e.x,a=e.y,i=e.width,o=e.height,s=e.fill,d=e.opacity,c=n.key;return null==t||null==c?null:(0,m.jsx)(P.animated.rect,xr({tabIndex:u?0:void 0,className:"visx-bar",x:r,y:a,width:i,height:o,fill:br(t.fill)?t.fill:s,opacity:d},l),c)}))})}function wr(e){return null==e.radius?(0,m.jsx)(Cr,xr({},e)):(0,m.jsx)(kr,xr(xr({},e),{},{radius:e.radius}))}try{wr.displayName="AnimatedBars",wr.__docgenInfo={description:"Wrapper component which renders a Bars component depending on whether it needs rounded corners.",displayName:"AnimatedBars",props:{bars:{defaultValue:null,description:"",name:"bars",required:!0,type:{name:"Bar[]"}},xScale:{defaultValue:null,description:"",name:"xScale",required:!0,type:{name:"XScale"}},yScale:{defaultValue:null,description:"",name:"yScale",required:!0,type:{name:"YScale"}},horizontal:{defaultValue:null,description:"",name:"horizontal",required:!1,type:{name:"boolean"}},radiusAll:{defaultValue:null,description:"Whether to apply radius to all corners.",name:"radiusAll",required:!1,type:{name:"boolean"}},radiusTop:{defaultValue:null,description:"Whether to apply radius to top corners.",name:"radiusTop",required:!1,type:{name:"boolean"}},radiusRight:{defaultValue:null,description:"Whether to apply radius to right corners.",name:"radiusRight",required:!1,type:{name:"boolean"}},radiusBottom:{defaultValue:null,description:"Whether to apply radius to bottom corners.",name:"radiusBottom",required:!1,type:{name:"boolean"}},radiusLeft:{defaultValue:null,description:"Whether to apply radius to left corners.",name:"radiusLeft",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/AnimatedBars.tsx#AnimatedBars"]={docgenInfo:wr.__docgenInfo,name:"AnimatedBars",path:"../visx-xychart/src/components/series/private/AnimatedBars.tsx#AnimatedBars"})}catch(ta){}var Ar=["colorAccessor"];function Dr(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Vr(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Dr(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Dr(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Tr(e){var t=e.colorAccessor,n=(0,o.Z)(e,Ar);return(0,m.jsx)(Rn,Vr(Vr({},n),{},{colorAccessor:t,BarsComponent:wr}))}try{Tr.displayName="AnimatedBarSeries",Tr.__docgenInfo={description:"",displayName:"AnimatedBarSeries",props:{radius:{defaultValue:null,description:"Optional radius to apply to bar corners.",name:"radius",required:!1,type:{name:"number"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},radiusAll:{defaultValue:null,description:"Whether to apply radius to all corners.",name:"radiusAll",required:!1,type:{name:"boolean"}},radiusTop:{defaultValue:null,description:"Whether to apply radius to top corners.",name:"radiusTop",required:!1,type:{name:"boolean"}},radiusRight:{defaultValue:null,description:"Whether to apply radius to right corners.",name:"radiusRight",required:!1,type:{name:"boolean"}},radiusBottom:{defaultValue:null,description:"Whether to apply radius to bottom corners.",name:"radiusBottom",required:!1,type:{name:"boolean"}},radiusLeft:{defaultValue:null,description:"Whether to apply radius to left corners.",name:"radiusLeft",required:!1,type:{name:"boolean"}},barPadding:{defaultValue:null,description:"Specify bar padding when bar thickness does not come from a `band` scale.\nAccepted values are [0, 1], 0 = no padding, 1 = no bar, defaults to 0.1.",name:"barPadding",required:!1,type:{name:"number"}},colorAccessor:{defaultValue:null,description:"Given a Datum, returns its color. Falls back to theme color if unspecified or if a null-ish value is returned.",name:"colorAccessor",required:!1,type:{name:"(d: Datum, index: number) => string"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/AnimatedBarSeries.tsx#AnimatedBarSeries"]={docgenInfo:Tr.__docgenInfo,name:"AnimatedBarSeries",path:"../visx-xychart/src/components/series/AnimatedBarSeries.tsx#AnimatedBarSeries"})}catch(ta){}function jr(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function qr(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?jr(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):jr(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Br(e){return(0,m.jsx)(zn,qr(qr({},e),{},{BarsComponent:wr}))}try{Br.displayName="AnimatedBarStack",Br.__docgenInfo={description:"",displayName:"AnimatedBarStack",props:{children:{defaultValue:null,description:"`BarSeries` elements, note we can't strictly enforce this with TS yet.",name:"children",required:!0,type:{name:'ReactElement<Pick<BaseBarSeriesProps<XScale, YScale, Datum>, "radius" | "onFocus" | "onBlur" | "onPointerDown" | "onPointerMove" | "onPointerUp" | ... 12 more ... | "colorAccessor">, string | ... 1 more ... | (new (props: any) => Component<...>)> | ReactElement<...>[]'}},offset:{defaultValue:null,description:"Sets the stack offset to the pre-defined d3 offset, see https://github.com/d3/d3-shape#stack_offset.",name:"offset",required:!1,type:{name:'"none" | "expand" | "diverging" | "silhouette" | "wiggle"'}},order:{defaultValue:null,description:"Sets the stack order to the pre-defined d3 function, see https://github.com/d3/d3-shape#stack_order.",name:"order",required:!1,type:{name:'"none" | "ascending" | "descending" | "reverse" | "insideout"'}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/AnimatedBarStack.tsx#AnimatedBarStack"]={docgenInfo:Br.__docgenInfo,name:"AnimatedBarStack",path:"../visx-xychart/src/components/series/AnimatedBarStack.tsx#AnimatedBarStack"})}catch(ta){}function _r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Yr(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?_r(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):_r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Rr(e){return(0,m.jsx)(xn,Yr(Yr({},e),{},{BarsComponent:wr}))}try{Rr.displayName="AnimatedBarGroup",Rr.__docgenInfo={description:"",displayName:"AnimatedBarGroup",props:{children:{defaultValue:null,description:"`BarSeries` elements",name:"children",required:!0,type:{name:"ReactNode"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},padding:{defaultValue:null,description:"Group band scale padding, [0, 1] where 0 = no padding, 1 = no bar.",name:"padding",required:!1,type:{name:"number"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},sortBars:{defaultValue:null,description:"Comparator function to sort `dataKeys` within a bar group. By default the DOM rendering order of `BarGroup`s `children` is used.",name:"sortBars",required:!1,type:{name:"(dataKeyA: string, dataKeyB: string) => number"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/AnimatedBarGroup.tsx#AnimatedBarGroup"]={docgenInfo:Rr.__docgenInfo,name:"AnimatedBarGroup",path:"../visx-xychart/src/components/series/AnimatedBarGroup.tsx#AnimatedBarGroup"})}catch(ta){}function Lr(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Xr(e){var t=e.xScale,n=e.yScale,r=e.horizontal,i=_t(t),o=_t(n);return(0,a.useMemo)((function(){return{unique:!0,from:function(e){var t=e.x,n=e.y,a=e.color;return{x:r?i:t,y:r?n:o,color:gr(a),opacity:0}},leave:function(e){var t=e.x,n=e.y,a=e.color;return{x:r?i:t,y:r?n:o,color:gr(a),opacity:0}},enter:function(e){var t=e.x,n=e.y,r=e.color;return{x:t,y:n,color:gr(r),opacity:1}},update:function(e){var t=e.x,n=e.y,r=e.color;return{x:t,y:n,color:gr(r),opacity:1}},keys:function(e){return e.key}}}),[i,o,r])}function Nr(e){var t=e.renderGlyph,n=e.glyphs,r=e.horizontal,a=e.xScale,o=e.yScale,l=e.onBlur,s=e.onFocus,u=e.onPointerMove,d=e.onPointerOut,c=e.onPointerUp,p=(0,P.useTransition)(n,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Lr(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Lr(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({},Xr({xScale:a,yScale:o,horizontal:r})));return(0,m.jsx)(m.Fragment,{children:p((function(e,n,r){var a=e.x,i=e.y,o=e.color,p=e.opacity,f=r.key;return(0,m.jsx)(P.animated.g,{transform:(0,P.to)([a,i],(function(e,t){return"translate(".concat(e,", ").concat(t,")")})),color:o,opacity:p,children:t({key:f,datum:n.datum,index:n.index,x:0,y:0,size:n.size,color:br(n.color)?n.color:"currentColor",onBlur:l,onFocus:s,onPointerMove:u,onPointerOut:d,onPointerUp:c})},f)}))})}try{Xr.displayName="useAnimatedGlyphsConfig",Xr.__docgenInfo={description:"Memoized useTransition config",displayName:"useAnimatedGlyphsConfig",props:{xScale:{defaultValue:null,description:"",name:"xScale",required:!0,type:{name:"XScale"}},yScale:{defaultValue:null,description:"",name:"yScale",required:!0,type:{name:"YScale"}},horizontal:{defaultValue:null,description:"",name:"horizontal",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/AnimatedGlyphs.tsx#useAnimatedGlyphsConfig"]={docgenInfo:Xr.__docgenInfo,name:"useAnimatedGlyphsConfig",path:"../visx-xychart/src/components/series/private/AnimatedGlyphs.tsx#useAnimatedGlyphsConfig"})}catch(ta){}try{Nr.displayName="AnimatedGlyphs",Nr.__docgenInfo={description:"",displayName:"AnimatedGlyphs",props:{renderGlyph:{defaultValue:null,description:"",name:"renderGlyph",required:!0,type:{name:"FC<GlyphProps<Datum>>"}},xScale:{defaultValue:null,description:"",name:"xScale",required:!0,type:{name:"XScale"}},yScale:{defaultValue:null,description:"",name:"yScale",required:!0,type:{name:"YScale"}},horizontal:{defaultValue:null,description:"",name:"horizontal",required:!1,type:{name:"boolean"}},glyphs:{defaultValue:null,description:"",name:"glyphs",required:!0,type:{name:"GlyphProps<Datum>[]"}},onBlur:{defaultValue:null,description:"Callback to invoke for onBlur.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onFocus:{defaultValue:null,description:"Callback to invoke for onFocus.",name:"onFocus",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerMove:{defaultValue:null,description:"Callback to invoke for onPointerMove.",name:"onPointerMove",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},onPointerOut:{defaultValue:null,description:"Callback to invoke for onPointerOut.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},onPointerUp:{defaultValue:null,description:"Callback to invoke for onPointerUp.",name:"onPointerUp",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/private/AnimatedGlyphs.tsx#AnimatedGlyphs"]={docgenInfo:Nr.__docgenInfo,name:"AnimatedGlyphs",path:"../visx-xychart/src/components/series/private/AnimatedGlyphs.tsx#AnimatedGlyphs"})}catch(ta){}var Fr=["renderGlyph"];function Ir(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Gr(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Ir(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Ir(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Kr(e){var t=e.renderGlyph,n=void 0===t?Ft:t,r=(0,o.Z)(e,Fr),i=(0,a.useCallback)((function(e){return(0,m.jsx)(Nr,Gr(Gr({},e),{},{renderGlyph:n}))}),[n]);return(0,m.jsx)(Nt,Gr(Gr({},r),{},{renderGlyphs:i}))}try{Kr.displayName="AnimatedGlyphSeries",Kr.__docgenInfo={description:"",displayName:"AnimatedGlyphSeries",props:{onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},size:{defaultValue:null,description:"The size of a `Glyph`, a `number` or a function which takes a `Datum` and returns a `number`.",name:"size",required:!1,type:{name:"number | ((d: Datum) => number)"}},dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},colorAccessor:{defaultValue:null,description:"Given a Datum, returns its color. Falls back to theme color if unspecified or if a null-ish value is returned.",name:"colorAccessor",required:!1,type:{name:"(d: Datum, index: number) => string"}},renderGlyph:{defaultValue:null,description:"",name:"renderGlyph",required:!1,type:{name:"FC<GlyphProps<Datum>>"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/AnimatedGlyphSeries.tsx#AnimatedGlyphSeries"]={docgenInfo:Kr.__docgenInfo,name:"AnimatedGlyphSeries",path:"../visx-xychart/src/components/series/AnimatedGlyphSeries.tsx#AnimatedGlyphSeries"})}catch(ta){}function Mr(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Zr(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Mr(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Mr(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function zr(e){return(0,m.jsx)(ir,Zr(Zr({},e),{},{PathComponent:cr}))}try{zr.displayName="AnimatedLineSeries",zr.__docgenInfo={description:"",displayName:"AnimatedLineSeries",props:{curve:{defaultValue:null,description:"Sets the curve factory (from @visx/curve or d3-curve) for the line generator. Defaults to curveLinear.",name:"curve",required:!1,type:{name:"CurveFactory | CurveFactoryLineOnly"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: FocusEvent<SVGPathElement>) => void)"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"((event: FocusEvent<Element>) => void) & ((event: FocusEvent<SVGPathElement>) => void)"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"(({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"((event: PointerEvent<Element>) => void) & ((event: PointerEvent<SVGPathElement>) => void)"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},colorAccessor:{defaultValue:null,description:"Given a datakey, returns its color. Falls back to theme color if unspecified or if a null-ish value is returned.",name:"colorAccessor",required:!1,type:{name:"(dataKey: string) => string"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/components/series/AnimatedLineSeries.tsx#AnimatedLineSeries"]={docgenInfo:zr.__docgenInfo,name:"AnimatedLineSeries",path:"../visx-xychart/src/components/series/AnimatedLineSeries.tsx#AnimatedLineSeries"})}catch(ta){}function Hr(e){var t=e.theme,n=void 0===t?He:t,r=e.children;return(0,m.jsx)(We.Provider,{value:n,children:r})}try{Hr.displayName="ThemeProvider",Hr.__docgenInfo={description:"",displayName:"ThemeProvider",props:{theme:{defaultValue:null,description:"",name:"theme",required:!1,type:{name:"XYChartTheme"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/providers/ThemeProvider.tsx#ThemeProvider"]={docgenInfo:Hr.__docgenInfo,name:"ThemeProvider",path:"../visx-xychart/src/providers/ThemeProvider.tsx#ThemeProvider"})}catch(ta){}var Wr=ze({backgroundColor:"#222",colors:[Xe.cyan[4],Xe.teal[1],Xe.yellow[2],Xe.red[4],Xe.grape[3],Xe.grape[6],Xe.pink[3]],tickLength:4,svgLabelSmall:{fill:Ne[2]},svgLabelBig:{fill:Ne[0]},gridColor:Ne[4],gridColorDark:Ne[1]});try{BarSeries.displayName="BarSeries",BarSeries.__docgenInfo={description:"",displayName:"BarSeries",props:{radius:{defaultValue:null,description:"Optional radius to apply to bar corners.",name:"radius",required:!1,type:{name:"number"}},onFocus:{defaultValue:null,description:"Callback invoked for onFocus events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onFocus",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onBlur:{defaultValue:null,description:"Callback invoked for onBlur events for the nearest Datum to the FocusEvent.\nXYChart will NOT capture and emit FocusEvents, they are emitted from individual Series glyph shapes.",name:"onBlur",required:!1,type:{name:"(event: FocusEvent<Element>) => void"}},onPointerDown:{defaultValue:null,description:"Callback invoked for onPointerDown events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerDown",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerMove:{defaultValue:null,description:"Callback invoked for onPointerMove events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerMove",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerUp:{defaultValue:null,description:"Callback invoked for onPointerUp events for the nearest Datum to the PointerEvent.\nBy default XYChart will capture and emit PointerEvents, invoking this function for\nany Series with a defined handler. Alternatively you may set <XYChart captureEvents={false} />\nand Series will emit their own events.",name:"onPointerUp",required:!1,type:{name:"({ datum, distanceX, distanceY, event, index, key, svgPoint, }: EventHandlerParams<Datum>) => void"}},onPointerOut:{defaultValue:null,description:"Callback invoked for onPointerOut events. By default XYChart will capture and emit\nPointerEvents, invoking this function for any Series with a defined handler.\nAlternatively you may set <XYChart captureEvents={false} /> and Series will emit\ntheir own events.",name:"onPointerOut",required:!1,type:{name:"(event: PointerEvent<Element>) => void"}},data:{defaultValue:null,description:"Data for the Series.",name:"data",required:!0,type:{name:"Datum[]"}},dataKey:{defaultValue:null,description:"Required data key for the Series, should be unique across all series.",name:"dataKey",required:!0,type:{name:"string"}},xAccessor:{defaultValue:null,description:"Given a Datum, returns the x-scale value.",name:"xAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<XScale>"}},yAccessor:{defaultValue:null,description:"Given a Datum, returns the y-scale value.",name:"yAccessor",required:!0,type:{name:"(d: Datum) => ScaleInput<YScale>"}},enableEvents:{defaultValue:null,description:"Whether the Series emits and subscribes to PointerEvents and FocusEvents (including Tooltip triggering).",name:"enableEvents",required:!1,type:{name:"boolean"}},radiusAll:{defaultValue:null,description:"Whether to apply radius to all corners.",name:"radiusAll",required:!1,type:{name:"boolean"}},radiusTop:{defaultValue:null,description:"Whether to apply radius to top corners.",name:"radiusTop",required:!1,type:{name:"boolean"}},radiusRight:{defaultValue:null,description:"Whether to apply radius to right corners.",name:"radiusRight",required:!1,type:{name:"boolean"}},radiusBottom:{defaultValue:null,description:"Whether to apply radius to bottom corners.",name:"radiusBottom",required:!1,type:{name:"boolean"}},radiusLeft:{defaultValue:null,description:"Whether to apply radius to left corners.",name:"radiusLeft",required:!1,type:{name:"boolean"}},barPadding:{defaultValue:null,description:"Specify bar padding when bar thickness does not come from a `band` scale.\nAccepted values are [0, 1], 0 = no padding, 1 = no bar, defaults to 0.1.",name:"barPadding",required:!1,type:{name:"number"}},colorAccessor:{defaultValue:null,description:"Given a Datum, returns its color. Falls back to theme color if unspecified or if a null-ish value is returned.",name:"colorAccessor",required:!1,type:{name:"(d: Datum, index: number) => string"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/index.ts#BarSeries"]={docgenInfo:BarSeries.__docgenInfo,name:"BarSeries",path:"../visx-xychart/src/index.ts#BarSeries"})}catch(ta){}try{XYChartTheme.displayName="XYChartTheme",XYChartTheme.__docgenInfo={description:"A complete chart theme includes style definitions for all axis orientations.",displayName:"XYChartTheme",props:{}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/index.ts#XYChartTheme"]={docgenInfo:XYChartTheme.__docgenInfo,name:"XYChartTheme",path:"../visx-xychart/src/index.ts#XYChartTheme"})}catch(ta){}try{src.displayName="src",src.__docgenInfo={description:"Provides a simplified API to build a full XYChartTheme.",displayName:"src",props:{backgroundColor:{defaultValue:null,description:"",name:"backgroundColor",required:!0,type:{name:"string"}},colors:{defaultValue:null,description:"",name:"colors",required:!0,type:{name:"string[]"}},svgLabelBig:{defaultValue:null,description:"",name:"svgLabelBig",required:!1,type:{name:"TextProps"}},svgLabelSmall:{defaultValue:null,description:"",name:"svgLabelSmall",required:!1,type:{name:"TextProps"}},htmlLabel:{defaultValue:null,description:"",name:"htmlLabel",required:!1,type:{name:"CSSProperties"}},xAxisLineStyles:{defaultValue:null,description:"",name:"xAxisLineStyles",required:!1,type:{name:'Pick<SVGAttributes<SVGLineElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | "radius" | ... 455 more ... | "onTransitionEndCapture">'}},yAxisLineStyles:{defaultValue:null,description:"",name:"yAxisLineStyles",required:!1,type:{name:'Pick<SVGAttributes<SVGLineElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | "radius" | ... 455 more ... | "onTransitionEndCapture">'}},xTickLineStyles:{defaultValue:null,description:"",name:"xTickLineStyles",required:!1,type:{name:'Pick<SVGAttributes<SVGLineElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | "radius" | ... 455 more ... | "onTransitionEndCapture">'}},yTickLineStyles:{defaultValue:null,description:"",name:"yTickLineStyles",required:!1,type:{name:'Pick<SVGAttributes<SVGLineElement>, "string" | "children" | "scale" | "width" | "height" | "x" | "y" | "dx" | "dy" | "className" | "stroke" | "radius" | ... 455 more ... | "onTransitionEndCapture">'}},tickLength:{defaultValue:null,description:"",name:"tickLength",required:!0,type:{name:"number"}},gridColor:{defaultValue:null,description:"",name:"gridColor",required:!0,type:{name:"string"}},gridColorDark:{defaultValue:null,description:"",name:"gridColorDark",required:!0,type:{name:"string"}},gridStyles:{defaultValue:null,description:"",name:"gridStyles",required:!1,type:{name:"CSSProperties"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["../visx-xychart/src/index.ts#src"]={docgenInfo:src.__docgenInfo,name:"src",path:"../visx-xychart/src/index.ts#src"})}catch(ta){}var Ur=n(55739),Jr=n(48719),Qr=Object.values(r),$r=[Jr.default];var ea=function(){return(0,m.jsx)(Ur.Z,{components:Qr,examples:$r,readme:"# @visx/xychart\n\n<a title=\"@visx/xychart npm downloads\" href=\"https://www.npmjs.com/package/@visx/xychart\">\n  <img src=\"https://img.shields.io/npm/dm/@visx/xychart.svg?style=flat-square\" />\n</a>\n\nIn contrast to other `visx` packages which are low-level, this package seeks to abstract some of the\ncomplexity of common visualization engineering, and exposes a **high-level** x,y (cartesian\ncoordinate) chart API. However, it is implemented using modularized `React.context` layers for\ntheme, canvas dimensions, x/y/color scales, data, events, and tooltips which allows for more\nexpressivity and advanced use cases.\n\nOut of the box it supports the following:\n\n- \\* many common `<*Series />` types (animated or not) such as lines, bars, etc.\n- \\* `<Axis />` (animated or not)\n- \\* `<Grid />` (animated or not)\n- \\* `<Annotation />` (animated or not)\n- \\* `<Tooltip />`\n- \\* `theme`ing\n\nThe following illustrates basic usage to create an animated line chart with a bottom `Axis`, `Grid`,\nand `Tooltip`:\n\n```tsx\nimport {\n  AnimatedAxis, // any of these can be non-animated equivalents\n  AnimatedGrid,\n  AnimatedLineSeries,\n  XYChart,\n  Tooltip,\n} from '@visx/xychart';\n\nconst data1 = [\n  { x: '2020-01-01', y: 50 },\n  { x: '2020-01-02', y: 10 },\n  { x: '2020-01-03', y: 20 },\n];\n\nconst data2 = [\n  { x: '2020-01-01', y: 30 },\n  { x: '2020-01-02', y: 40 },\n  { x: '2020-01-03', y: 80 },\n];\n\nconst accessors = {\n  xAccessor: (d) => d.x,\n  yAccessor: (d) => d.y,\n};\n\nconst render = () => (\n  <XYChart height={300} xScale={{ type: 'band' }} yScale={{ type: 'linear' }}>\n    <AnimatedAxis orientation=\"bottom\" />\n    <AnimatedGrid columns={false} numTicks={4} />\n    <AnimatedLineSeries dataKey=\"Line 1\" data={data1} {...accessors} />\n    <AnimatedLineSeries dataKey=\"Line 2\" data={data2} {...accessors} />\n    <Tooltip\n      snapTooltipToDatumX\n      snapTooltipToDatumY\n      showVerticalCrosshair\n      showSeriesGlyphs\n      renderTooltip={({ tooltipData, colorScale }) => (\n        <div>\n          <div style={{ color: colorScale(tooltipData.nearestDatum.key) }}>\n            {tooltipData.nearestDatum.key}\n          </div>\n          {accessors.xAccessor(tooltipData.nearestDatum.datum)}\n          {', '}\n          {accessors.yAccessor(tooltipData.nearestDatum.datum)}\n        </div>\n      )}\n    />\n  </XYChart>\n);\n```\n\nSee sections below for more detailed guidance and advanced usage, or explore the comprehensive API\nbelow.\n\n<hr />\n\n## Basic usage\n\n<details>\n  <summary>Installation</summary>\n\n```\nnpm install --save @visx/xychart react-spring\n```\n\nNote: `react-spring` is a required `peerDependency` for importing `Animated*` components.\n\n</details>\n\n<details>\n  <summary>Series types</summary>\n\nThe following `Series` types are currently supported and we are happy to review or consider\nadditional Series types in the future.\n\n| Component name        | Description                                                                                      | Usage                                                |\n| --------------------- | ------------------------------------------------------------------------------------------------ | ---------------------------------------------------- | --- |\n| (Animated)AreaSeries  | Connect data points with a `<path />`, with a color fill to the zero baseline                    | `<AreaSeries />`                                     |\n| (Animated)BarSeries   | Render a `<rect />` for each data point                                                          | `<BarSeries />`                                      |\n| (Animated)BarGroup    | Group multiple child `<BarSeries />` values together                                             | `<BarGroup><BarSeries /><BarSeries />...</BarGroup>` |\n| (Animated)BarStack    | Stack multiple child `<BarSeries />` values together                                             | `<BarStack><BarSeries /><BarSeries />...</BarStack>` |     |\n| (Animated)GlyphSeries | Render a `Glyph` (any shape, defaults to `<circle />`) for each data point, e.g., a scatter plot | `<GlyphSeries renderGlyph={() => ...} />`            |\n| (Animated)LineSeries  | Connect data points with a `<path>`                                                              | `<GlyphSeries />`                                    |\n\nAll `Series` have animated and non-animated variants to give you more control over your bundle size,\nsupport missing (`null`) data, and can be rendered vertically or horizontally.\n\n</details>\n\n<details>\n  <summary>Theming</summary>\n\nDefault `lightTheme` and `darkTheme` themes are exported from `@visx/xychart` and the utility\n`buildChartTheme` is exported to support easy creation of custom themes.\n\n```ts\nimport { buildChartTheme, XYChart } from '@visx/xychart';\nimport { TextProps as SVGTextProps } from '@visx/text/lib/Text'; // just for types\n\nconst customTheme = buildChartTheme({\n  // colors\n  backgroundColor: string; // used by Tooltip, Annotation\n  colors: string[]; // categorical colors, mapped to series via `dataKey`s\n\n  // labels\n  svgLabelBig?: SVGTextProps;\n  svgLabelSmall?: SVGTextProps;\n  htmlLabel?: HTMLTextStyles;\n\n  // lines\n  xAxisLineStyles?: LineStyles;\n  yAxisLineStyles?: LineStyles;\n  xTickLineStyles?: LineStyles;\n  yTickLineStyles?: LineStyles;\n  tickLength: number;\n\n  // grid\n  gridColor: string;\n  gridColorDark: string; // used for axis baseline if x/yxAxisLineStyles not set\n  gridStyles?: CSSProperties;\n});\n\n() => <XYChart theme={customTheme} />\n```\n\n</details>\n\n<details>\n  <summary>Tooltips</summary>\n\n`@visx/tooltip` `Tooltip`s are integrated into `@visx/xychart`, and should be rendered as a child of\n`XYChart` (or a child where `TooltipContext` is provided).\n\n**`Tooltip` positioning** is handled by the `Tooltip` itself, based on `TooltipContext`. `Tooltip`\nis rendered inside a `Portal`, avoiding clipping by parent DOM elements with higher z-index\ncontexts. See the API below for a full list of `props` to support additional behavior, such as\nsnapping to data point positions and rendering cross-hairs.\n\n**`Tooltip` content** is controlled by the specified `prop.renderTooltip` which has access to:\n\n- `tooltipData.nearestDatum` \u2013 the globally closest `Datum`, **across all** `Series`'s `dataKey`s\n- `tooltipData.datumByKey` \u2013 the closest `Datum` **for each** `Series`'s `dataKey`; this enables\n  \"shared tooltips\" where you can render the nearest data point for each `Series`.\n- a shared `colorScale` which maps `Series`'s `dataKey`s to `theme` colors\n\n</details>\n\n<details>\n  <summary>Event handlers</summary>\n\nThe following `PointerEvent`s (handling both `MouseEvent`s and `TouchEvent`s) are currently\nsupported. They may be set on individual `Series` components (e.g.,\n`<BarSeries onPointerMove={() => ...} />`), or at the chart level (e.g.,\n`<XYChart onPointerMove={() => {}} />`) in which case they are invoked once for _every_ `*Series`.\nTo **disable** event emitting for any `Series` set `<*Series enableEvents=false />`. The\n`onFocus/onBlur` handlers enable you to make your chart events and `Tooltip`s accessible via\nkeyboard interaction. Note that the current implementation requires your target browser to support\nthe `SVG 2.0` spec for `tabIndex` on `SVG` elements.\n\nBelow, `HandlerParms` has the following type signature:\n\n```ts\ntype EventHandlerParams<Datum> = {\n  datum: Datum; // nearest Datum to event, for Series with `dataKey=key`\n  distanceX: number; // x distance between event and Datum, in px\n  distanceY;: number; // y distance between event and Datum, in px\n  event: React.PointerEvent | React.FocusEvent; // the event\n  index: number; // index of Datum in Series `data` array\n  key: string; // `dataKey` of Series to which `Datum` belongs\n  svgPoint: { x: number; y: number }; // event position in svg-coordinates\n};\n```\n\n| Prop name       | Signature                                     | `XYChart` support | `*Series` support |\n| --------------- | --------------------------------------------- | ----------------- | ----------------- |\n| `onPointerMove` | `(params: EventHandlerParams<Datum>) => void` | \u2705                | \u2705                |\n| `onPointerOut`  | `(event: React.PointerEvent) => void`         | \u2705                | \u2705                |\n| `onPointerUp`   | `(params: EventHandlerParams<Datum>) => void` | \u2705                | \u2705                |\n| `onPointerDown` | `(params: EventHandlerParams<Datum>) => void` | \u2705                | \u2705                |\n| `onFocus`       | `(params: EventHandlerParams<Datum>) => void` | \u274c                | \u2705                |\n| `onBlur`        | `(event: React.TouchEvent) => void`           | \u274c                | \u2705                |\n\n</details>\n\n<details>\n  <summary>Annotations</summary>\n\nComposable `@visx/annotations` annotations are integrated into `@visx/xychart` and use its theme and\ndimension context. These components allow for annotation of individual points using\n`AnnotationCircleSubject`, or x- or y-thresholds using `AnnotationLineSubject`.\n\n[CodeSandbox](https://codesandbox.io/s/annotations-8npmf?file=/Example.tsx)\n\n```tsx\nimport React from 'react';\nimport {\n  Annotation,\n  AnnotationLabel,\n  AnnotationConnector,\n  AnnotationCircleSubject,\n  Grid,\n  LineSeries,\n  XYChart,\n} from '@visx/xychart';\n\nconst data = [\n  { x: '2020-01-01', y: 50 },\n  { x: '2020-01-02', y: 10 },\n  { x: '2020-01-03', y: 20 },\n  { x: '2020-01-04', y: 5 },\n];\n\nconst labelXOffset = -40;\nconst labelYOffset = -50;\nconst chartConfig = {\n  xScale: { type: 'band' },\n  yScale: { type: 'linear' },\n  height: 300,\n  margin: { top: 10, right: 10, bottom: 10, left: 10 },\n};\n\nexport default () => (\n  <XYChart {...chartConfig}>\n    <Grid numTicks={3} />\n    <LineSeries dataKey=\"line\" data={data} xAccessor={d => d.x} yAccessor={d => d.y} />\n    <Annotation\n      dataKey=\"line\" // use this Series's accessor functions, alternatively specify x/yAccessor here\n      datum={data[2]}\n      dx={labelXOffset}\n      dy={labelYOffset}\n    >\n      {/** Text label */}\n      <AnnotationLabel\n        title=\"Title\"\n        subtitle=\"Subtitle deets\"\n        showAnchorLine={false}\n        backgroundFill=\"rgba(0,150,150,0.1)\"\n      />\n      {/** Draw circle around point */}\n      <AnnotationCircleSubject />\n      {/** Connect label to CircleSubject */}\n      <AnnotationConnector />\n    </AnimatedAnnotation>\n  </XYChart>\n);\n```\n\n</details>\n\n<hr />\n\n##### \u26a0\ufe0f `ResizeObserver` dependency\n\nResponsive `XYChart`s, `Tooltip`, and `AnnotationLabel` components rely on\n[`ResizeObserver`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)s. If your\nbrowser target needs a polyfill, you can either pollute the `window` object or inject it cleanly\nusing the `resizeObserverPolyfill` prop for these components. A polyfill passed to `XYChart` will be\naccessible to child `Tooltip` and `AnnotationLabel` components.\n\n<details>\n  <summary>Examples \u2705 \u274c</summary>\n\n\u274c `Error: This browser does not support ResizeObserver out of the box`\n\n```tsx\n// no polyfill, no browser support\n() => <XYChart {...} />\n() => <XYChart {...}><Tooltip /></XYChart>\n\n```\n\n\u2705 No errors\n\n```tsx\n// no polyfill, target browser supports ResizeObserver\n() => <XYChart {...} />\n() => <XYChart {...}><Tooltip /></XYChart>\n\n// import the polyfill in the needed module, or set it on `window` object\nimport ResizeObserver from 'resize-observer-polyfill';\n() => <XYChart {...}><Tooltip /></XYChart> // \ud83d\ude0e\n\n// cleanly pass polyfill to component that needs it\nimport ResizeObserver from 'resize-observer-polyfill';\n() => (\n  <XYChart resizeObserverPolyfill={ResizeObserver} {...}>\n    <Tooltip />\n  </XYChart>\n)\n```\n\n  </details>\n\n<hr />\n\n## Advanced usage\n\n<details>\n  <summary>Examples</summary>\n\n`XYChart` is implemented using modularized `React.context` layers for scales, canvas dimensions,\ndata, events, and tooltips which enables more advanced usage than many other chart-level\nabstractions.\n\nBy default `XYChart` renders all context providers if a given context is not available, but you can\nshare context across multiple `XYChart`s to implement functionality such as linked tooltips, shared\nthemes, or shared data.\n\n- [`ThemeProvider` + custom theme chart background example](https://codesandbox.io/s/themeprovider-sbdvz?file=/Example.tsx)\n- [`DataProvider/EventEmitterProvider` example of linked tooltips / small multiples](https://codesandbox.io/s/linked-tooltips-7s0jz?file=/Example.tsx)\n- [`TooltipProvider` example of programmatic + keyboard tooltip triggering](https://codesandbox.io/s/programmatic-tooltips-hh7ly?file=/Example.tsx)\n\n</details>\n\n<details>\n  <summary>DataContext</summary>\n\nThis context provides chart canvas dimensions (`width`, `height`, and `margin`), x/y/color scales,\nand a data registry. The data registry includes data from all child `*Series`, and x/y/color scales\nare updated accordingly accounting for canvas dimensions.\n\n</details>\n\n<details>\n  <summary>ThemeContext</summary>\n\nThis context provides an `XYChart` theme, its used by all visual elements that compose a chart, and\ncan be used to render custom visual elements that are on theme.\n\n</details>\n\n<details>\n  <summary>EventEmitterContext</summary>\n\nThis context provides an event publishing / subscription object which can be used via the\n`useEventEmitter` hook. `Series` and `XYChart` events, including tooltip updates, are emitted and\nhandled with through this context.\n\n[CodeSandbox](https://codesandbox.io/s/eventemitterprovider-w8jhl?file=/Example.tsx)\n\n```tsx\nimport React, { useState } from 'react';\nimport { useEventEmitter, EventEmitterProvider } from '@visx/xychart';\n\nconst eventSourceId = 'optional-source-id-filter';\n\nconst EmitEvent = () => {\n  const emit = useEventEmitter();\n  return (\n    <button onPointerUp={(event) => emit('pointerup', event, eventSourceId)}>emit event</button>\n  );\n};\n\nconst SubscribeToEvent = () => {\n  const [clickCount, setClickCount] = useState(0);\n  const allowedEventSources = [eventSourceId];\n  useEventEmitter('pointerup', () => setClickCount(clickCount + 1), allowedEventSources);\n\n  return <div>Emitted {clickCount} events</div>;\n};\n\nexport default function Example() {\n  return (\n    <EventEmitterProvider>\n      <EmitEvent />\n      <SubscribeToEvent />\n    </EventEmitterProvider>\n  );\n}\n```\n\n</details>\n\n<details>\n  <summary>TooltipContext</summary>\n\nThis context provides access to `@visx/tooltip`s `useTooltip` state, including whether the tooltip\nis visible (`tooltipOpen`), tooltlip position (`tooltipLeft`, `tooltipTop`),\n`tooltipData: { nearestDatum, datumByKey }` described above, and functions to update context\n(`hideTooltip`, `showTooltip`, and `updateTooltip`).\n\n</details>\n\n<hr />\n",visxPackage:"xychart"})}},47520:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/xychart",function(){return n(15707)}])},14557:function(e,t,n){"use strict";n.d(t,{Z:function(){return u}});var r=n(13980),a=n.n(r),i=n(2784),o=n(72779),l=n.n(o),s=n(89549);function u(e){var t=e.top,n=void 0===t?0:t,r=e.left,a=void 0===r?0:r,o=e.className,u=e.children;return i.createElement(s.Z,{className:l()("visx-glyph",o),top:n,left:a},u)}u.propTypes={top:a().number,left:a().number,className:a().string,children:a().node}},24766:function(e,t,n){"use strict";n.d(t,{Z:function(){return m}});var r=n(13980),a=n.n(r),i=n(2784),o=n(72779),l=n.n(o),s=n(24037),u=n(86707),d=n(14557),c=["children","className","top","left","size"];function p(){return(p=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function m(e){var t=e.children,n=e.className,r=e.top,a=e.left,o=e.size,m=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,c),f=(0,s.Z)();return f.type(u.Z),("number"===typeof o||o)&&f.size(o),t?i.createElement(i.Fragment,null,t({path:f})):i.createElement(d.Z,{top:r,left:a},i.createElement("path",p({className:l()("visx-glyph-star",n),d:f()||""},m)))}m.propTypes={children:a().func,className:a().string,top:a().number,left:a().number,size:a().oneOfType([a().number,a().func])}},82790:function(e,t,n){"use strict";n.d(t,{Z:function(){return i}});var r=n(4696),a=(0,n(63458).Z)("domain","range","reverse","clamp","interpolate","nice","round");function i(e){return a((0,r.Z)(),e)}},87520:function(e,t,n){"use strict";n.d(t,{Nb:function(){return p},SO:function(){return m},jv:function(){return f},ve:function(){return h},aJ:function(){return y},kn:function(){return v}});var r=n(38764),a=n(79493),i=n(79767),o=n(15001),l=n(8329),s=n(98926),u=n(19616),d=n(42679),c=n(70271);function p(e){var t=void 0===e?{}:e,n=t.innerRadius,a=t.outerRadius,i=t.cornerRadius,o=t.startAngle,l=t.endAngle,s=t.padAngle,d=t.padRadius,c=(0,r.Z)();return null!=n&&(0,u.Z)(c.innerRadius,n),null!=a&&(0,u.Z)(c.outerRadius,a),null!=i&&(0,u.Z)(c.cornerRadius,i),null!=o&&(0,u.Z)(c.startAngle,o),null!=l&&(0,u.Z)(c.endAngle,l),null!=s&&(0,u.Z)(c.padAngle,s),null!=d&&(0,u.Z)(c.padRadius,d),c}function m(e){var t=void 0===e?{}:e,n=t.x,r=t.x0,i=t.x1,o=t.y,l=t.y0,s=t.y1,d=t.defined,c=t.curve,p=(0,a.Z)();return n&&(0,u.Z)(p.x,n),r&&(0,u.Z)(p.x0,r),i&&(0,u.Z)(p.x1,i),o&&(0,u.Z)(p.y,o),l&&(0,u.Z)(p.y0,l),s&&(0,u.Z)(p.y1,s),d&&p.defined(d),c&&p.curve(c),p}function f(e){var t=void 0===e?{}:e,n=t.x,r=t.y,a=t.defined,o=t.curve,l=(0,i.Z)();return n&&(0,u.Z)(l.x,n),r&&(0,u.Z)(l.y,r),a&&l.defined(a),o&&l.curve(o),l}function h(e){var t=void 0===e?{}:e,n=t.startAngle,r=t.endAngle,a=t.padAngle,i=t.value,l=t.sort,s=t.sortValues,d=(0,o.Z)();return(null===l||null!=l)&&d.sort(l),(null===s||null!=s)&&d.sortValues(s),null!=i&&d.value(i),null!=a&&(0,u.Z)(d.padAngle,a),null!=n&&(0,u.Z)(d.startAngle,n),null!=r&&(0,u.Z)(d.endAngle,r),d}function y(e){var t=void 0===e?{}:e,n=t.angle,r=t.radius,a=t.defined,i=t.curve,o=(0,l.Z)();return n&&(0,u.Z)(o.angle,n),r&&(0,u.Z)(o.radius,r),a&&o.defined(a),i&&o.curve(i),o}function v(e){var t=e.keys,n=e.value,r=e.order,a=e.offset,i=(0,s.Z)();return t&&i.keys(t),n&&(0,u.Z)(i.value,n),r&&i.order((0,d.ZP)(r)),a&&i.offset((0,c.ZP)(a)),i}},19616:function(e,t,n){"use strict";function r(e,t){e(t)}n.d(t,{Z:function(){return r}})},70271:function(e,t,n){"use strict";n.d(t,{nW:function(){return s},ed:function(){return u},ZP:function(){return d}});var r=n(22254),a=n(76751),i=n(90541),o=n(36538),l=n(34928),s={expand:r.Z,diverging:a.Z,none:i.Z,silhouette:o.Z,wiggle:l.Z},u=Object.keys(s);function d(e){return e&&s[e]||s.none}},42679:function(e,t,n){"use strict";n.d(t,{un:function(){return s},s2:function(){return u},ZP:function(){return d}});var r=n(19721),a=n(82564),i=n(12197),o=n(81182),l=n(40277),s={ascending:r.Z,descending:a.Z,insideout:i.Z,none:o.Z,reverse:l.Z},u=Object.keys(s);function d(e){return e&&s[e]||s.none}},66601:function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}n.d(t,{Z:function(){return r}})},29931:function(e,t,n){"use strict";function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function a(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e}n.d(t,{Z:function(){return a}})},23712:function(e,t,n){"use strict";function r(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}n.d(t,{Z:function(){return r}})}},function(e){e.O(0,[9774,1603,5592,5450,377,1224,4696,4930,5868,4735,1028,3136,8231,485,6543,764,155,6634,9582,6947,7035,2888,179],(function(){return t=47520,e(e.s=t);var t}));var t=e.O();_N_E=t}]);